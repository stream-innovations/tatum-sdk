
/*
 * Tatum API Reference
 *
 * # Welcome to the Tatum API Reference!  ## What is Tatum? ## What is Tatum?  Tatum offers a flexible framework to build, run, and scale blockchain apps fast. To learn more about the Tatum blockchain development framework, visit [our website](https://tatum.io/framework).  The Tatum API features powerful endpoints that simplify a complex blockchain into single API requests. Code for all supported blockchains using unified API calls.  ## Need help?  To chat with other developers, get help from the Support team, and engage with the thriving Tatum community, join  our [Discord server](https://discord.com/invite/tatum). For more information about how to work with Tatum, review the [online documentation](https://docs.tatum.io/).  ## About this API Reference  The Tatum API Reference is based on OpenAPI Specification v3.1.0 with a few [vendor extensions](https://github.com/Redocly/redoc/blob/master/docs/redoc-vendor-extensions.md) applied.  # Authentication  When using the Tatum API, you authenticate yourself with an **API key**. <SecurityDefinitions /> 
 *
 * API version: 3.16.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package tatum

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type NotificationSubscriptionsApiService service
/*
NotificationSubscriptionsApiService Create a subscription
&lt;p&gt;&lt;b&gt;2 credits per API call + credits spent on subscriptions themselves&lt;br/&gt; Each subscription type consumes a different number of credits.&lt;/b&gt;&lt;/p&gt; &lt;p&gt;For Free plans, there is a monthly limit of sent webhooks, which is &lt;b&gt;1000&lt;/b&gt;.&lt;/p&gt; &lt;p&gt;If the webhook is sent unsuccessfully, it will be retried. The number of retries depends on the plan. &lt;/p&gt; &lt;ul&gt;   &lt;li&gt;&lt;b&gt;Free Plan&lt;/b&gt; - 3 retries&lt;/li&gt;   &lt;li&gt;&lt;b&gt;Paid plans&lt;/b&gt; - 10 retries&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Create a subscription as an HTTP web hook.&lt;/p&gt; &lt;p&gt;The following subscription types are available:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;b&gt;ADDRESS_TRANSACTION&lt;/b&gt; - Enable HTTP POST JSON notifications for any blockchain transaction (both incoming and outgoing) at a specified address. This notification applies to transactions in the native blockchain currency or with any type of blockchain tokens.&lt;br/&gt; - For &lt;b&gt;EMV-based blockchains&lt;/b&gt; (ETH), this web hook is first invoked when a transaction appears in the mempool, and then it is invoked again once the transaction is added to a block.&lt;br/&gt; - For the &lt;b&gt;other blockchains&lt;/b&gt;, this webhook is invoked when a transaction is added to a block.&lt;br/&gt; Free community plans can monitor up to 10 addresses per plan.&lt;br/&gt; The following table describes the availability of this notification type on different blockchains and the credit consumption:&lt;br/&gt; &lt;table&gt;   &lt;tr&gt;     &lt;th&gt;Chain&lt;/th&gt;     &lt;th&gt;Testnet/Mainnet&lt;/th&gt;     &lt;th&gt;Token assets support&lt;/th&gt;     &lt;th&gt;Plan limitation&lt;/th&gt;     &lt;th&gt;Credit consumption / day / address&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Solana&lt;/td&gt;     &lt;td&gt;Yes/Yes&lt;/td&gt;     &lt;td&gt;SOL, SPL and NFTs&lt;/td&gt;     &lt;td&gt;Free plans - 10 addresses across all blockchains, Paid plans - unlimited addresses across all blockchains&lt;/td&gt;     &lt;td&gt;50 credits / day / address&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Ethereum&lt;/td&gt;     &lt;td&gt;Yes/Yes&lt;/td&gt;     &lt;td&gt;ETH, Internal transfers, ERC20, ERC721, ERC1155&lt;/td&gt;     &lt;td&gt;Free plans - 10 addresses across all blockchains, Paid plans - unlimited addresses across all blockchains&lt;/td&gt;     &lt;td&gt;25 credits / day / address&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Polygon&lt;/td&gt;     &lt;td&gt;Yes/Yes&lt;/td&gt;     &lt;td&gt;MATIC, ERC20, ERC721, ERC1155&lt;/td&gt;     &lt;td&gt;Free plans - 10 addresses across all blockchains, Paid plans - unlimited addresses across all blockchains&lt;/td&gt;     &lt;td&gt;40 credits / day / address&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Celo&lt;/td&gt;     &lt;td&gt;Yes/Yes&lt;/td&gt;     &lt;td&gt;CELO, Internal transfers, ERC20, ERC721, ERC1155&lt;/td&gt;     &lt;td&gt;Free plans - 10 addresses across all blockchains, Paid plans - unlimited addresses across all blockchains&lt;/td&gt;     &lt;td&gt;25 credits / day / address&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Klaytn&lt;/td&gt;     &lt;td&gt;Yes/Yes&lt;/td&gt;     &lt;td&gt;Klay, ERC20, ERC721, ERC1155&lt;/td&gt;     &lt;td&gt;Free plans - 10 addresses across all blockchains, Paid plans - unlimited addresses across all blockchains&lt;/td&gt;     &lt;td&gt;25 credits / day / address&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Bitcoin&lt;/td&gt;     &lt;td&gt;Yes/Yes&lt;/td&gt;     &lt;td&gt;BTC&lt;/td&gt;     &lt;td&gt;Free plans - 10 addresses across all blockchains, Paid plans - unlimited addresses across all blockchains&lt;/td&gt;     &lt;td&gt;5 credits / day / address&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Litecoin&lt;/td&gt;     &lt;td&gt;Yes/Yes&lt;/td&gt;     &lt;td&gt;LTC&lt;/td&gt;     &lt;td&gt;Free plans - 10 addresses across all blockchains, Paid plans - unlimited addresses across all blockchains&lt;/td&gt;     &lt;td&gt;7 credits / day / address&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Bitcoin Cash&lt;/td&gt;     &lt;td&gt;Yes/Yes&lt;/td&gt;     &lt;td&gt;BCH, only incoming transactions&lt;/td&gt;     &lt;td&gt;Free plans - 10 addresses across all blockchains, Paid plans - unlimited addresses across all blockchains&lt;/td&gt;     &lt;td&gt;5 credits / day / address&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Dogecoin&lt;/td&gt;     &lt;td&gt;Yes/Yes&lt;/td&gt;     &lt;td&gt;DOGE, only incoming transactions&lt;/td&gt;     &lt;td&gt;Free plans - 10 addresses across all blockchains, Paid plans - unlimited addresses across all blockchains&lt;/td&gt;     &lt;td&gt;7 credits / day / address&lt;/td&gt;   &lt;/tr&gt;    &lt;tr&gt;     &lt;td&gt;Tron&lt;/td&gt;     &lt;td&gt;Yes/Yes&lt;/td&gt;     &lt;td&gt;Tron, TRC10/TRC20&lt;/td&gt;     &lt;td&gt;Free plans - 10 addresses across all blockchains, Paid plans - unlimited addresses across all blockchains&lt;/td&gt;     &lt;td&gt;30 credits / day / address&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Binance Smart Chain&lt;/td&gt;     &lt;td&gt;Yes/Yes&lt;/td&gt;     &lt;td&gt;BSC, BEP20, ERC721, ERC1155&lt;/td&gt;     &lt;td&gt;Free plans - 10 addresses across all blockchains, Paid plans - unlimited addresses across all blockchains&lt;/td&gt;     &lt;td&gt;40 credits / day / address&lt;/td&gt;   &lt;/tr&gt; &lt;/table&gt; The request body of the POST request is a JSON object with the following structure:&lt;br/&gt; &lt;pre&gt;{   \&quot;address\&quot;: \&quot;FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ\&quot;, // the address on which the transaction occurs; for EVM-based chains, this is the recipient&#x27;s address   \&quot;txId\&quot;: \&quot;2rdy3YCZHSwvpWtuDom1d4Jjy5UU9STLxF3ffXau6GToReDkfw8wEgX541fvzvh6btVC5D8iNapcKTXfPsoDBk7A\&quot;, // the transaction ID   \&quot;blockNumber\&quot;: 110827114, // the block number; does not appear if the transaction is in the mempool (for EMV-based blockchains)   \&quot;asset\&quot;: \&quot;3gUeeR3BfVhukYJMwtHownRtRkGcf1bvwiV8TbKMZBVz\&quot;, // the asset of the transaction: for token assets, this is the token address; for native blochckain assets, this is the name of the asset (for example, SOL)   \&quot;amount\&quot;: \&quot;1\&quot;, // the amount of the asset that was credited to (+) or debited from (-) the address; for EVM-based chains, when \&quot;counterAddress\&quot; is present, the amount is always positive   \&quot;tokenId\&quot;: \&quot;1\&quot;, // (ERC-721 / ERC-1155 only) the ID of the transferred token   \&quot;type\&quot;: \&quot;token\&quot;, // the type of the transaction; can be either \&quot;native\&quot; or \&quot;token\&quot;   \&quot;mempool\&quot;: true, // (EMV-based blockchains only) if appears and set to \&quot;true\&quot;, the transaction is in the mempool; if set to \&quot;false\&quot; or does not appear at all, the transaction has been added to a block   \&quot;counterAddress\&quot;: undefined // an optional counter party address of the transaction; for EVM-based blockchains, this is the recipient&#x27;s address }&lt;/pre&gt; &lt;b&gt;5 credits are debited for each fired web hook.&lt;/b&gt;&lt;br/&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;CONTRACT_NFT_TXS_PER_BLOCK&lt;/b&gt; - Enable HTTP POST JSON notifications for any event of minting, transferring, or burning an NFT that was emitted from any smart contract. This notification is fired as a batch notification per block: it includes all NFT minting, transferring, or burning events from all smart contracts that got recorded into a block.&lt;br/&gt; Free community plans can monitor 1 event across all blockchains per plan.&lt;br/&gt;&lt;br/&gt; The following table describes the availability of this notification type on different blockchains and the credit consumption:&lt;br/&gt; &lt;table&gt;   &lt;tr&gt;     &lt;th&gt;Chain&lt;/th&gt;     &lt;th&gt;Available chains (the \&quot;chain\&quot; parameter in the response payload)&lt;/th&gt;     &lt;th&gt;Credit consumption / day&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Ethereum&lt;/td&gt;     &lt;td&gt;ethereum-sepolia / ethereum-mainnet&lt;/td&gt;     &lt;td&gt;500,000 credits / day&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Polygon&lt;/td&gt;     &lt;td&gt;polygon-mumbai / polygon-mainnet&lt;/td&gt;     &lt;td&gt;500,000 credits / day&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Celo&lt;/td&gt;     &lt;td&gt;celo-testnet / celo-mainnet&lt;/td&gt;     &lt;td&gt;500,000 credits / day&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Klaytn&lt;/td&gt;     &lt;td&gt;klaytn-baobab / klaytn-cypress&lt;/td&gt;     &lt;td&gt;500,000 credits / day&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;BNB Smart Chain&lt;/td&gt;     &lt;td&gt;bsc-testnet / bsc-mainnet&lt;/td&gt;     &lt;td&gt;500,000 credits / day&lt;/td&gt;   &lt;/tr&gt; &lt;/table&gt; The request body of the POST request is a JSON object with the following structure:&lt;br/&gt; &lt;pre&gt;{  \&quot;events\&quot;: [    {      \&quot;timestamp\&quot;: 1661961758000,      \&quot;from\&quot;: \&quot;0x0000000000000000000000000000000000000000\&quot;,      \&quot;to\&quot;: \&quot;0xfa4e7035b34294407e5df1603215983d65e5a773\&quot;,      \&quot;tokenId\&quot;: \&quot;14671\&quot;,      \&quot;txId\&quot;: \&quot;0x916fcf878656f7a3772317697e6d2740ac8b1b7dbe6d029aa79592fd72f3fb0b\&quot;,      \&quot;contractAddress\&quot;: \&quot;0x55a2430e32dcebc3649120f26f917d1f0686f74c\&quot;,      \&quot;type\&quot;: \&quot;erc721\&quot;,      \&quot;amount\&quot;: \&quot;1\&quot;,      \&quot;logIndex\&quot;: 578,      \&quot;metadataURI\&quot;: \&quot;https://graphigo.prd.galaxy.eco/metadata/0x55a2430e32dcebc3649120f26f917d1f0686f74c/14671.json\&quot;    }  ],  \&quot;blockNumber\&quot;: 32522207,  \&quot;chain\&quot;: \&quot;polygon-mainnet\&quot;,  \&quot;subscriptionType\&quot;: \&quot;CONTRACT_NFT_TXS_PER_BLOCK\&quot;  }&lt;/pre&gt; &lt;b&gt;1 credit is debited for each fired web hook.&lt;/b&gt;&lt;br/&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;CONTRACT_MULTITOKEN_TXS_PER_BLOCK&lt;/b&gt; - Enable HTTP POST JSON notifications for any event of minting, transferring, or burning a Multi-Token that was emitted from any smart contract. This notification is fired as a batch notification per block: it includes all Multi Token minting, transferring, or burning events from all smart contracts that got recorded into a block.&lt;br/&gt; Free community plans can monitor 1 event across all blockchains per plan.&lt;br/&gt;&lt;br/&gt; The following table describes the availability of this notification type on different blockchains and the credit consumption:&lt;br/&gt; &lt;table&gt;   &lt;tr&gt;     &lt;th&gt;Chain&lt;/th&gt;     &lt;th&gt;Available chains (the \&quot;chain\&quot; parameter in the response payload)&lt;/th&gt;     &lt;th&gt;Credit consumption / day&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Ethereum&lt;/td&gt;     &lt;td&gt;ethereum-sepolia / ethereum-mainnet&lt;/td&gt;     &lt;td&gt;500,000 credits / day&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Polygon&lt;/td&gt;     &lt;td&gt;polygon-mumbai / polygon-mainnet&lt;/td&gt;     &lt;td&gt;500,000 credits / day&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Celo&lt;/td&gt;     &lt;td&gt;celo-testnet / celo-mainnet&lt;/td&gt;     &lt;td&gt;500,000 credits / day&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Klaytn&lt;/td&gt;     &lt;td&gt;klaytn-baobab / klaytn-cypress&lt;/td&gt;     &lt;td&gt;500,000 credits / day&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;BNB Smart Chain&lt;/td&gt;     &lt;td&gt;bsc-testnet / bsc-mainnet&lt;/td&gt;     &lt;td&gt;500,000 credits / day&lt;/td&gt;   &lt;/tr&gt; &lt;/table&gt; The request body of the POST request is a JSON object with the following structure:&lt;br/&gt; &lt;pre&gt;{  \&quot;events\&quot;: [    {      \&quot;timestamp\&quot;: 1661961758000,      \&quot;from\&quot;: \&quot;0x85bd970cf0e49acd572f9c2d608713bc55b5ee0e\&quot;,      \&quot;to\&quot;: \&quot;0x9ab31230d5413e4af01af9bb697651a3c70c95c9\&quot;,      \&quot;tokenId\&quot;: \&quot;1450000023306\&quot;,      \&quot;txId\&quot;: \&quot;0x565b9ca6b7b5ff1b1ce0725acd785dbf5ff0930d5ff547bad044c0960291555f\&quot;,      \&quot;contractAddress\&quot;: \&quot;0xdb6290f355a528a7284bdd528b05a78fb05226ca\&quot;,      \&quot;type\&quot;: \&quot;erc1155\&quot;,      \&quot;amount\&quot;: \&quot;1\&quot;,      \&quot;logIndex\&quot;: 571,      \&quot;metadataURI\&quot;: \&quot;https://touhao.bj.bcebos.com/nft/metadata/1450000023306.json\&quot;    }  ],  \&quot;blockNumber\&quot;: 32522207,  \&quot;chain\&quot;: \&quot;polygon-mainnet\&quot;,  \&quot;subscriptionType\&quot;: \&quot;CONTRACT_MULTITOKEN_TXS_PER_BLOCK\&quot; }&lt;/pre&gt; &lt;b&gt;1 credit is debited for each fired web hook.&lt;/b&gt;&lt;br/&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;CONTRACT_LOG_EVENT&lt;/b&gt; - Enable HTTP POST JSON notifications for any event that was emitted from any smart contract. This notification is fired as a batch notification per block: it includes all events from all smart contracts that got recorded into a block.&lt;br/&gt; Free community plans can monitor 1 event across all blockchains per plan.&lt;br/&gt;&lt;br/&gt; The following table describes the availability of this notification type on different blockchains and the credit consumption:&lt;br/&gt; &lt;table&gt;   &lt;tr&gt;     &lt;th&gt;Chain&lt;/th&gt;     &lt;th&gt;Available chains (the \&quot;chain\&quot; parameter in the response payload)&lt;/th&gt;     &lt;th&gt;Credit consumption / day&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Ethereum&lt;/td&gt;     &lt;td&gt;ethereum-sepolia / ethereum-mainnet&lt;/td&gt;     &lt;td&gt;50,000 credits / day&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Polygon&lt;/td&gt;     &lt;td&gt;polygon-mumbai / polygon-mainnet&lt;/td&gt;     &lt;td&gt;50,000 credits / day&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Celo&lt;/td&gt;     &lt;td&gt;celo-testnet / celo-mainnet&lt;/td&gt;     &lt;td&gt;50,000 credits / day&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Klaytn&lt;/td&gt;     &lt;td&gt;klaytn-baobab / klaytn-cypress&lt;/td&gt;     &lt;td&gt;50,000 credits / day&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;BNB Smart Chain&lt;/td&gt;     &lt;td&gt;bsc-testnet / bsc-mainnet&lt;/td&gt;     &lt;td&gt;50,000 credits / day&lt;/td&gt;   &lt;/tr&gt; &lt;/table&gt; The request body of the POST request is a JSON object with the following structure:&lt;br/&gt; &lt;pre&gt;{  \&quot;events\&quot;: [    {      \&quot;txId\&quot;: \&quot;0xc98307f09ed527d5cff8305e8f65226b790e3317ded10b9e58f6f07286dcf8f1\&quot;,      \&quot;logIndex\&quot;: 326,      \&quot;timestamp\&quot;: 1661774265000,      \&quot;address\&quot;: \&quot;0xc2132d05d31c914a87c6611c10748aeb04b58e8f\&quot;,      \&quot;topic_0\&quot;: \&quot;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\&quot;,      \&quot;topic_1\&quot;: \&quot;0x000000000000000000000000a91ab7d77892a559d2a95baaf1d748fc97c65d29\&quot;,      \&quot;topic_2\&quot;: \&quot;0x0000000000000000000000009b08288c3be4f62bbf8d1c20ac9c5e6f9467d8b7\&quot;,      \&quot;topic_3\&quot;: null,      \&quot;data\&quot;: \&quot;0x0000000000000000000000000000000000000000000000000000000002c9e3e4\&quot;    }  ],  \&quot;blockNumber\&quot;: 32447538,  \&quot;chain\&quot;: \&quot;polygon-mumbai\&quot;,  \&quot;subscriptionType\&quot;: \&quot;CONTRACT_LOG_EVENT\&quot; }&lt;/pre&gt; &lt;b&gt;1 credit is debited for each fired web hook.&lt;/b&gt;&lt;br/&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;ACCOUNT_INCOMING_BLOCKCHAIN_TRANSACTION&lt;/b&gt; - Enable HTTP POST JSON notifications about incoming blockchain transactions on virtual accounts. This web hook is invoked when an incoming transaction is reflected on the balance of the virtual account (the balance is credited with the transaction amount). This happens when the transaction has the sufficient number of blockchain confirmations: two confirmations for BTC, LTC, BCH, and DOGE, and one confirmation for the other blockchains.&lt;br/&gt; The request body of the POST request is a JSON object with the following structure: &lt;pre&gt;{   \&quot;date\&quot;: 1619176527481,   \&quot;amount\&quot;: \&quot;0.005\&quot;,   \&quot;currency\&quot;: \&quot;BTC\&quot;,   \&quot;accountId\&quot;: \&quot;6082ab462936b4478117c6a0\&quot;,   \&quot;reference: \&quot;c9875708-4ba3-41c9-a4cd-271048b41b9a\&quot;, // the reference of the transaction in the virtual account   \&quot;txId\&quot;: \&quot;45af182a0ffab58e5ba32fee57b297b2260c6e23a1de5ddc76c7ee22d72dea99\&quot;,   \&quot;blockHash\&quot;: \&quot;45af182a0ffab58e5ba32fee57b297b2260c6e23a1de5ddc76c7ee22d72dea99\&quot;, // the hash of the block, might not be present every time   \&quot;blockHeight\&quot;: 12345,   \&quot;from\&quot;: \&quot;SENDER_ADDRESS\&quot;, // might not be present every time; not present for UTXO-based blockchains   \&quot;to\&quot;: \&quot;RECIPIENT_ADDRESS_CONNECTED_TO_LEDGER_ACCOUNT\&quot;, // the blockchain address of the recipient   \&quot;index\&quot;: 5 // for UTXO-based blockchains (BCH, BTC, DOGE, LTC), this is the index of the output in the transaction }&lt;/pre&gt; 1 credit is debited for each monitored account every day.&lt;/li&gt; &lt;li&gt;&lt;b&gt;ACCOUNT_PENDING_BLOCKCHAIN_TRANSACTION&lt;/b&gt; - Enable HTTP POST JSON notifications about incoming blockchain transactions on virtual accounts.&lt;br /&gt; This web hook is supported only for BCH, BTC, DOGE, ETH, and LTC accounts.&lt;br /&gt; - For &lt;b&gt;BTC-based blockchains&lt;/b&gt; (BCH, BTC, DOGE, and LTC), this web hook is invoked when an incoming transaction appears in a block for the first time. At that time, the transaction has one confirmation but this is not enough for the transaction to be reflected on the balance of the virtual account yet. Instead, a deposit corresponding to the pending transaction with a status of \&quot;in progress\&quot; appears on the virtual account. Once the transaction is added to the block, the deposit&#x27;s status changes to \&quot;done\&quot;, and the account balance gets updated.&lt;br /&gt; - For &lt;b&gt;EMV-based blockchains&lt;/b&gt; (ETH), this web hook is invoked when an incoming transaction appears in the mempool. The virtual account balance is not updated until the transaction is added to a block. Instead, a deposit corresponding to the pending transaction with a status of \&quot;in progress\&quot; appears on the virtual account. Once the transaction is added to the block, the deposit&#x27;s status changes to \&quot;done\&quot;, and the account balance gets updated.&lt;br /&gt; The request body of the POST request is a JSON object with the following structure:&lt;br/&gt; &lt;pre&gt;{   \&quot;date\&quot;: 1619176527481,   \&quot;amount\&quot;: \&quot;0.005\&quot;,   \&quot;currency\&quot;: \&quot;BTC\&quot;,   \&quot;accountId\&quot;: \&quot;6082ab462936b4478117c6a0\&quot;,   \&quot;reference: \&quot;c9875708-4ba3-41c9-a4cd-271048b41b9a\&quot;, // the reference of the transaction in the virtual account   \&quot;txId\&quot;: \&quot;45af182a0ffab58e5ba32fee57b297b2260c6e23a1de5ddc76c7ee22d72dea99\&quot;,   \&quot;blockHash\&quot;: \&quot;45af182a0ffab58e5ba32fee57b297b2260c6e23a1de5ddc76c7ee22d72dea99\&quot;, // the hash of the block, might not be present every time; if set to \&quot;null\&quot;, the transaction is in the mempool (for EMV-based blockchains)   \&quot;blockHeight\&quot;: 12345, // if set to \&quot;null\&quot;, the transaction is in the mempool (for EMV-based blockchains)   \&quot;from\&quot;: \&quot;SENDER_ADDRESS\&quot;, // might not be present every time; not present for UTXO-based blockchains (BCH, BTC, DOGE, LTC)   \&quot;to\&quot;: \&quot;RECIPIENT_ADDRESS_CONNECTED_TO_LEDGER_ACCOUNT\&quot;, // the blockchain address of the recipient   \&quot;index\&quot;: 5 // for UTXO-based blockchains (BCH, BTC, DOGE, LTC), this is the index of the output in the transaction }&lt;/pre&gt; 1 credit is debited for each monitored account every day.&lt;/li&gt; &lt;li&gt;&lt;b&gt;CUSTOMER_TRADE_MATCH&lt;/b&gt; - Enable HTTP POST JSON notifications on closed trade, which occurs on any customer account. This web hook will be invoked, when the open trade is filled and closed. Works also for the Trade Futures. If is triggered by the futures, bool field expiredWithoutMatch is present. Request body of the POST request will be JSON object with attributes:&lt;br/&gt; &lt;pre&gt;{   \&quot;created\&quot;: 1619176527481,   \&quot;amount\&quot;: \&quot;0.005\&quot;,   \&quot;price\&quot;: \&quot;0.02\&quot;,   \&quot;type\&quot;: \&quot;SELL\&quot;,   \&quot;pair\&quot;: \&quot;VC_CHF/VC_CHF3\&quot;,   \&quot;id\&quot;: \&quot;6082ab462936b4478117c6a0\&quot;, // id of the trade   \&quot;currency1AccountId\&quot;: \&quot;6082ab462936b4478117c6a0\&quot;,   \&quot;currency2AccountId\&quot;: \&quot;6082ab512936b4478117c6a2\&quot;,   \&quot;fee\&quot;: null,   \&quot;feeAccountId\&quot;: null,   \&quot;isMaker\&quot;: true,   \&quot;expiredWithoutMatch\&quot;: false }&lt;/pre&gt; 10 credits will be debited for every monitored customer every day.&lt;/li&gt; &lt;li&gt;&lt;b&gt;CUSTOMER_PARTIAL_TRADE_MATCH&lt;/b&gt; - Enable HTTP POST JSON notifications on partialy filled trade, which occurs on any customer account. This web hook will be invoked, when the open trade is partialy filled. Request body of the POST request will be JSON object with attributes:&lt;br/&gt; &lt;pre&gt;{   \&quot;created\&quot;: 1619176527481,   \&quot;amount\&quot;: \&quot;0.005\&quot;,   \&quot;orderAmount\&quot;: \&quot;0.1\&quot;,   \&quot;price\&quot;: \&quot;0.02\&quot;,   \&quot;type\&quot;: \&quot;SELL\&quot;,   \&quot;pair\&quot;: \&quot;VC_CHF/VC_CHF3\&quot;,   \&quot;id\&quot;: \&quot;6082ab462936b4478117c6a0\&quot;, // id of the trade   \&quot;currency1AccountId\&quot;: \&quot;6082ab462936b4478117c6a0\&quot;,   \&quot;currency2AccountId\&quot;: \&quot;6082ab512936b4478117c6a2\&quot;,   \&quot;fee\&quot;: null,   \&quot;feeAccountId\&quot;: null,   \&quot;isMaker\&quot;: true,   \&quot;expiredWithoutMatch\&quot;: false }&lt;/pre&gt; 10 credits will be debited for every monitored customer every day.&lt;/li&gt; &lt;li&gt;&lt;b&gt;TRANSACTION_IN_THE_BLOCK&lt;/b&gt; - Enable HTTP POST JSON notifications on ledger &#x3D;&gt; blockchain transaction, when transaction is included in the block. This web hook will be invoked, when the outgoing transaction is included in the block. Request body of the POST request will be JSON object with attributes:&lt;br/&gt; &lt;pre&gt;   {     \&quot;txId\&quot;: \&quot;0x026f4f05b972c09279111da13dfd20d8df04eff436d7f604cd97b9ffaa690567\&quot;,     \&quot;reference\&quot;: \&quot;90270634-5b07-4fad-b17b-f82899953533\&quot;,     \&quot;accountId\&quot;: \&quot;6086ed0744c45b24d4fbd039\&quot;,     \&quot;currency\&quot;: \&quot;BSC\&quot;,     \&quot;withdrawalId\&quot;: \&quot;608fe5b73a893234ba379ab2\&quot;,     \&quot;address\&quot;: \&quot;0x8ce4e40889a13971681391AAd29E88eFAF91f784\&quot;,     \&quot;amount\&quot;: \&quot;0.1\&quot;,     \&quot;blockHeight\&quot;: 8517664   }&lt;/pre&gt; 10 credits will be debited every day, 1 credit for every included transaction notified via web hook.&lt;/li&gt; &lt;li&gt;&lt;b&gt;KMS_FAILED_TX&lt;/b&gt; - Enable HTTP POST JSON notifications on error during KMS signature process. This web hook will be invoked, when the Tatum KMS receives error during processing transactions. Request body of the POST request will be JSON object with attributes:&lt;br/&gt; &lt;pre&gt;{   \&quot;signatureId\&quot;: \&quot;6082ab462936b4478117c6a0\&quot;,   \&quot;error\&quot;: \&quot;Error message from the KMS\&quot; }&lt;/pre&gt; 10 credits will be debited every day.&lt;/li&gt; &lt;li&gt;&lt;b&gt;KMS_COMPLETED_TX&lt;/b&gt; - Enable HTTP POST JSON notifications on successful completion of KMS signature process. This web hook will be invoked, when the Tatum KMS successfully completes the signature during processing transactions. Request body of the POST request will be JSON object with attributes:&lt;br/&gt; &lt;pre&gt;{   \&quot;signatureId\&quot;: \&quot;6082ab462936b4478117c6a0\&quot;,   \&quot;txId\&quot;: \&quot;0x7bb7d3b90567e89f999f2e3d263bc3738a018dbbcfa9f5397678cf17cdf0235f\&quot; }&lt;/pre&gt; 10 credits will be debited every day.&lt;/li&gt; &lt;li&gt;&lt;b&gt;ACCOUNT_BALANCE_LIMIT&lt;/b&gt; - Report with all account balances above desired limit.&lt;/li&gt; &lt;li&gt;&lt;b&gt;TRANSACTION_HISTORY_REPORT&lt;/b&gt; - Report with all ledger transactions for last X hours, where X is set by the subscription attribute as interval. Maximum number of transactions returned by this report is 20000. Transactions are obtained from the time of the invocation of the GET method to obtain report - X hours.&lt;/li&gt; &lt;/ul&gt; In case of unsuccesful web hook response status - other then 2xx - web hook is repeated 9 more times with exponential backoff. Parameters are T &#x3D; 15 * 2.7925^9, where 15 is interval in s, backoff rate is 2.7925 and 9 is current number of retries. Last web hook is fired after 24 hours approximatelly. After last failed attempt, web hook is deleted from our system. The 2xx response must be returned in 10 seconds after web hook is fired.&lt;br/&gt; Result of the operation is subscription ID, which can be used to cancel subscription or obtain additional data connected to it like reports.&lt;/p&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *NotificationSubscriptionsApiCreateSubscriptionOpts - Optional Parameters:
     * @param "TestnetType" (optional.String) -  Type of Ethereum testnet. Defaults to ethereum-sepolia.
@return Id
*/

type NotificationSubscriptionsApiCreateSubscriptionOpts struct {
    TestnetType optional.String
}

func (a *NotificationSubscriptionsApiService) CreateSubscription(ctx context.Context, body V3SubscriptionBody, localVarOptionals *NotificationSubscriptionsApiCreateSubscriptionOpts) (Id, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Id
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/subscription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.TestnetType.IsSet() {
		localVarQueryParams.Add("testnetType", parameterToString(localVarOptionals.TestnetType.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Id
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v InlineResponse40335
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NotificationSubscriptionsApiService Cancel existing subscription
&lt;h4&gt;1 credit for API call&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Cancel existing subscription.&lt;/p&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Subscription ID

*/
func (a *NotificationSubscriptionsApiService) DeleteSubscription(ctx context.Context, id string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/subscription/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
NotificationSubscriptionsApiService Disable HMAC webhook digest
&lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Disable HMAC hash ID on the fired webhooks from Tatum API.&lt;/p&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

*/
func (a *NotificationSubscriptionsApiService) DisableWebHookHmac(ctx context.Context) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/subscription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
NotificationSubscriptionsApiService Enable HMAC webhook digest
&lt;h4&gt;2 credits per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Enable HMAC hash ID on the fired webhooks from Tatum API. In order to make sure that a webhook is sent by us, we have the possibility to sign it with the HMAC Sha512 Hex algorithm.&lt;br/&gt; To verify that a webhook is sent by us &lt;ol&gt; &lt;li&gt;Get a webhook &lt;b&gt;x-payload-hash&lt;/b&gt; header value and payload as it is as a JSON file.&lt;/li&gt; &lt;li&gt;Convert the HTTP webhook body to stringify JSON without any spaces. In JavaScript, you would do it like this &lt;pre&gt;JSON.stringify(req.body)&lt;/pre&gt;&lt;/li&gt; &lt;li&gt;Perform calculations on your side to create a digest using Secret Key, webhook payload in bytes and HMAC SHA512 algorithm. JavaScript example: &lt;pre&gt;require(&#x27;crypto&#x27;).createHmac(&#x27;sha512&#x27;, hmacSecret).update(JSON.stringify(req.body)).digest(&#x27;base64&#x27;)&lt;/pre&gt;.&lt;/li&gt; &lt;li&gt;Compare x-payload-hash header value with calculated digest as a Base64 string.&lt;/li&gt;&lt;/p&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

*/
func (a *NotificationSubscriptionsApiService) EnableWebHookHmac(ctx context.Context, body HmacWebHook) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/subscription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
NotificationSubscriptionsApiService List all executed webhooks
&lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;List all webhooks.&lt;/p&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pageSize Max number of items per page is 50.
 * @param optional nil or *NotificationSubscriptionsApiGetAllWebhooksOpts - Optional Parameters:
     * @param "Offset" (optional.Float64) -  Offset to obtain the next page of data.
     * @param "Direction" (optional.String) -  Direction of sorting
     * @param "Failed" (optional.Bool) -  Flag indicating whether the webhook was successful or not
@return []WebHook
*/

type NotificationSubscriptionsApiGetAllWebhooksOpts struct {
    Offset optional.Float64
    Direction optional.String
    Failed optional.Bool
}

func (a *NotificationSubscriptionsApiService) GetAllWebhooks(ctx context.Context, pageSize float64, localVarOptionals *NotificationSubscriptionsApiGetAllWebhooksOpts) ([]WebHook, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []WebHook
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/subscription/webhook"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if pageSize < 1 {
		return localVarReturnValue, nil, reportError("pageSize must be greater than 1")
	}
	if pageSize > 50 {
		return localVarReturnValue, nil, reportError("pageSize must be less than 50")
	}

	localVarQueryParams.Add("pageSize", parameterToString(pageSize, ""))
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Direction.IsSet() {
		localVarQueryParams.Add("direction", parameterToString(localVarOptionals.Direction.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Failed.IsSet() {
		localVarQueryParams.Add("failed", parameterToString(localVarOptionals.Failed.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []WebHook
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NotificationSubscriptionsApiService Count of found entities for get webhook request
&lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Count of webhooks that were found from /v3/subscription/webhook&lt;/p&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pageSize Max number of items per page is 50.
 * @param optional nil or *NotificationSubscriptionsApiGetAllWebhooksCountOpts - Optional Parameters:
     * @param "Offset" (optional.Float64) -  Offset to obtain the next page of data.
     * @param "Direction" (optional.String) -  Direction of sorting
     * @param "Failed" (optional.Bool) -  Flag indicating whether the webhook was successful or not
@return EntitiesCount
*/

type NotificationSubscriptionsApiGetAllWebhooksCountOpts struct {
    Offset optional.Float64
    Direction optional.String
    Failed optional.Bool
}

func (a *NotificationSubscriptionsApiService) GetAllWebhooksCount(ctx context.Context, pageSize float64, localVarOptionals *NotificationSubscriptionsApiGetAllWebhooksCountOpts) (EntitiesCount, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue EntitiesCount
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/subscription/webhook/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if pageSize < 1 {
		return localVarReturnValue, nil, reportError("pageSize must be greater than 1")
	}
	if pageSize > 50 {
		return localVarReturnValue, nil, reportError("pageSize must be less than 50")
	}

	localVarQueryParams.Add("pageSize", parameterToString(pageSize, ""))
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Direction.IsSet() {
		localVarQueryParams.Add("direction", parameterToString(localVarOptionals.Direction.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Failed.IsSet() {
		localVarQueryParams.Add("failed", parameterToString(localVarOptionals.Failed.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v EntitiesCount
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NotificationSubscriptionsApiService Obtain report for subscription
&lt;h4&gt;1 credit for API call. Based on the required report type, additional credits may be charged.&lt;/h4&gt;&lt;br/&gt; &lt;p&gt;Obtain report from subscription based on its type. Following reports are supported: &lt;ul&gt; &lt;li&gt;&lt;b&gt;ACCOUNT_BALANCE_LIMIT&lt;/b&gt; - obtain list of all ledger accounts with account balance above the limit. 1 credit per 50 returned records is charged.&lt;/li&gt; &lt;li&gt;&lt;b&gt;TRANSACTION_HISTORY_REPORT&lt;/b&gt; - obtain list of all ledger transaction for last X hours from the time of invocation. 1 credit per 50 returned records is charged.&lt;/li&gt; &lt;/ul&gt;&lt;/p&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Subscription ID
@return InlineResponse20022
*/
func (a *NotificationSubscriptionsApiService) GetSubscriptionReport(ctx context.Context, id string) (InlineResponse20022, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse20022
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/subscription/report/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse20022
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v InlineResponse40336
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NotificationSubscriptionsApiService List all active subscriptions
&lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;List all active subscriptions.&lt;/p&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pageSize Max number of items per page is 50.
 * @param optional nil or *NotificationSubscriptionsApiGetSubscriptionsOpts - Optional Parameters:
     * @param "Offset" (optional.Float64) -  Offset to obtain next page of the data.
     * @param "Address" (optional.String) -  Value for filtering by address
@return []Subscription
*/

type NotificationSubscriptionsApiGetSubscriptionsOpts struct {
    Offset optional.Float64
    Address optional.String
}

func (a *NotificationSubscriptionsApiService) GetSubscriptions(ctx context.Context, pageSize float64, localVarOptionals *NotificationSubscriptionsApiGetSubscriptionsOpts) ([]Subscription, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Subscription
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/subscription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if pageSize < 1 {
		return localVarReturnValue, nil, reportError("pageSize must be greater than 1")
	}
	if pageSize > 50 {
		return localVarReturnValue, nil, reportError("pageSize must be less than 50")
	}

	localVarQueryParams.Add("pageSize", parameterToString(pageSize, ""))
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Address.IsSet() {
		localVarQueryParams.Add("address", parameterToString(localVarOptionals.Address.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Subscription
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NotificationSubscriptionsApiService Count of found entities for get webhook request
&lt;h4&gt;1 credit per API call.&lt;/h4&gt;&lt;br/&gt;&lt;p&gt;Count of subscriptions that were found from /v3/subscription&lt;/p&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pageSize Max number of items per page is 50.
 * @param optional nil or *NotificationSubscriptionsApiGetSubscriptionsCountOpts - Optional Parameters:
     * @param "Offset" (optional.Float64) -  Offset to obtain next page of the data.
     * @param "Address" (optional.String) -  Value for filtering by address
@return EntitiesCount
*/

type NotificationSubscriptionsApiGetSubscriptionsCountOpts struct {
    Offset optional.Float64
    Address optional.String
}

func (a *NotificationSubscriptionsApiService) GetSubscriptionsCount(ctx context.Context, pageSize float64, localVarOptionals *NotificationSubscriptionsApiGetSubscriptionsCountOpts) (EntitiesCount, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue EntitiesCount
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/subscription/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if pageSize < 1 {
		return localVarReturnValue, nil, reportError("pageSize must be greater than 1")
	}
	if pageSize > 50 {
		return localVarReturnValue, nil, reportError("pageSize must be less than 50")
	}

	localVarQueryParams.Add("pageSize", parameterToString(pageSize, ""))
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Address.IsSet() {
		localVarQueryParams.Add("address", parameterToString(localVarOptionals.Address.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v EntitiesCount
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
