
/*
 * Tatum API Reference
 *
 * # Welcome to the Tatum API Reference!  ## What is Tatum? ## What is Tatum?  Tatum offers a flexible framework to build, run, and scale blockchain apps fast. To learn more about the Tatum blockchain development framework, visit [our website](https://tatum.io/framework).  The Tatum API features powerful endpoints that simplify a complex blockchain into single API requests. Code for all supported blockchains using unified API calls.  ## Need help?  To chat with other developers, get help from the Support team, and engage with the thriving Tatum community, join  our [Discord server](https://discord.com/invite/tatum). For more information about how to work with Tatum, review the [online documentation](https://docs.tatum.io/).  ## About this API Reference  The Tatum API Reference is based on OpenAPI Specification v3.1.0 with a few [vendor extensions](https://github.com/Redocly/redoc/blob/master/docs/redoc-vendor-extensions.md) applied.  # Authentication  When using the Tatum API, you authenticate yourself with an **API key**. <SecurityDefinitions /> 
 *
 * API version: 3.16.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package tatum

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type NFTERC721OrCompatibleApiService service
/*
NFTERC721OrCompatibleApiService Add an NFT minter
&lt;p&gt;&lt;b&gt;2 credits per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Add new minter of NFT Tokens. This method adds minter permission to new minter address.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;b&gt;Signing a transaction&lt;/b&gt;&lt;/p&gt; &lt;p&gt;When adding an NFT minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.&lt;/p&gt; &lt;p&gt;Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the &lt;b&gt;testnet&lt;/b&gt; of a blockchain.&lt;/p&gt; &lt;p&gt;For signing transactions on the &lt;b&gt;mainnet&lt;/b&gt;, we strongly recommend that you use the Tatum &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Key Management System (KMS)&lt;/a&gt; and provide the signature ID instead of the private key in the API. Alternatively, you can use the &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-js\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum JavaScript client&lt;/a&gt;.&lt;/p&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *NFTERC721OrCompatibleApiNftAddMinterOpts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.
@return InlineResponse2005
*/

type NFTERC721OrCompatibleApiNftAddMinterOpts struct {
    XTestnetType optional.String
}

func (a *NFTERC721OrCompatibleApiService) NftAddMinter(ctx context.Context, body MintAddBody, localVarOptionals *NFTERC721OrCompatibleApiNftAddMinterOpts) (InlineResponse2005, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2005
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/nft/mint/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2005
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v InlineResponse40366
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NFTERC721OrCompatibleApiService Burn an NFT
&lt;p&gt;&lt;b&gt;100 credits per API call on Flow&lt;br/&gt; 2 credits per API call on the other blockchains&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Burn one NFT Token. This method destroys any NFT token from smart contract defined in contractAddress.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Algorand&lt;/li&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Flow&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;li&gt;TRON&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;b&gt;Signing a transaction&lt;/b&gt;&lt;/p&gt; &lt;p&gt;When burning an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.&lt;/p&gt; &lt;p&gt;Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the &lt;b&gt;testnet&lt;/b&gt; of a blockchain.&lt;/p&gt; &lt;p&gt;For signing transactions on the &lt;b&gt;mainnet&lt;/b&gt;, we strongly recommend that you use the Tatum &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Key Management System (KMS)&lt;/a&gt; and provide the signature ID instead of the private key in the API. Alternatively, you can use the &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-js\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum JavaScript client&lt;/a&gt;.&lt;/p&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *NFTERC721OrCompatibleApiNftBurnErc721Opts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.
@return InlineResponse2005
*/

type NFTERC721OrCompatibleApiNftBurnErc721Opts struct {
    XTestnetType optional.String
}

func (a *NFTERC721OrCompatibleApiService) NftBurnErc721(ctx context.Context, body NftBurnBody, localVarOptionals *NFTERC721OrCompatibleApiNftBurnErc721Opts) (InlineResponse2005, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2005
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/nft/burn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2005
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v InlineResponse40366
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NFTERC721OrCompatibleApiService Deploy an NFT smart contract
&lt;p&gt;&lt;b&gt;100 credits per API call on Flow&lt;br/&gt; 2 credits per API call on the other blockchains&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Deploy an NFT smart contract on the blockchain. In a deployed NFT smart contract, you can mint NFTs (one NFT at a time or multiple NFTs at once), burn, and transfer NFTs.&lt;br/&gt; Smart contracts are standardized and audited.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Flow&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;li&gt;TRON&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;By default, an NFT smart contract is deployed as a &lt;b&gt;general ERC-721 smart contract compatible with OpenSea royalties&lt;/b&gt;. This is a standard ERC-721 contract with &lt;code&gt;AccessControl&lt;/code&gt; and &lt;code&gt;Ownable&lt;/code&gt;, enhanced with NFT batch minting. NFTs minted in this smart contract are compatible with OpenSea and its royalty structure.&lt;p&gt; &lt;p&gt;In addition to the general ERC-721 contract, you can also deploy the following types of NFT smart contracts for the supported blockchains &lt;b&gt;except for Flow and TRON&lt;/b&gt;:&lt;p&gt; &lt;ul&gt; &lt;li&gt;&lt;b&gt;Cashback ERC-721 smart contract&lt;/b&gt; is an ERC-721 smart contract that forces on-chain royalties to be paid every time an NFT is transferred. The royalties are defined as a fixed value and are &lt;b&gt;not&lt;/b&gt; OpenSea-compatible.&lt;br /&gt; To deploy an NFT smart contract as a cashback contract, deploy the contract with the &lt;code&gt;cashback&lt;/code&gt; parameter set to &lt;code&gt;true&lt;/code&gt; in the request body.&lt;/li&gt; &lt;li&gt;&lt;b&gt;Provenance ERC-721 smart contract&lt;/b&gt; is an ERC-721 smart contract that forces on-chain royalties to be paid every time an NFT is transferred. The royalties are defined as a percentage of the NFT price and are &lt;b&gt;not&lt;/b&gt; OpenSea-compatible.&lt;br /&gt; To deploy an NFT smart contract as a provenance contract, deploy the contract with the &lt;code&gt;provenance&lt;/code&gt; parameter set to &lt;code&gt;true&lt;/code&gt; in the request body.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;You can enable public minting for cashback and provenance smart contracts. By default, public minting is disabled, which means that only the blockchain address whose private key was used to create the smart contract or the blockchain addresses &lt;a href&#x3D;\&quot;https://apidoc.tatum.io/tag/NFT-(ERC-721-or-compatible)#operation/NftAddMinter\&quot; target&#x3D;\&quot;_blank\&quot;&gt;added to the smart contract as NFT minters&lt;/a&gt; will be able to mint NFTs for the contract. To enable public minting and allow anyone to mint NFTs on top of the smart contract, deploy the contract with the &lt;code&gt;publicMint&lt;/code&gt; parameter set to &lt;code&gt;true&lt;/code&gt; in the request body.&lt;/p&gt; &lt;p&gt;You can review the code of a deployed NFT smart contract &lt;a href&#x3D;\&quot;https://github.com/tatumio/flow-contracts\&quot; target&#x3D;\&quot;_blank\&quot;&gt;here&lt;/a&gt; (if the contract is deployed on Flow) or &lt;a href&#x3D;\&quot;https://github.com/tatumio/smart-contracts/tree/master/contracts/tatum\&quot; target&#x3D;\&quot;_blank\&quot;&gt;here&lt;/a&gt; (if the contract is deployed on any other supported blockchain).&lt;/p&gt; &lt;p&gt;&lt;b&gt;Signing a transaction&lt;/b&gt;&lt;/p&gt; &lt;p&gt;When deploying an NFT smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.&lt;/p&gt; &lt;p&gt;Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the &lt;b&gt;testnet&lt;/b&gt; of a blockchain.&lt;/p&gt; &lt;p&gt;For signing transactions on the &lt;b&gt;mainnet&lt;/b&gt;, we strongly recommend that you use the Tatum &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Key Management System (KMS)&lt;/a&gt; and provide the signature ID instead of the private key in the API. Alternatively, you can use the &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-js\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum JavaScript client&lt;/a&gt;.&lt;/p&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *NFTERC721OrCompatibleApiNftDeployErc721Opts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.
@return InlineResponse2005
*/

type NFTERC721OrCompatibleApiNftDeployErc721Opts struct {
    XTestnetType optional.String
}

func (a *NFTERC721OrCompatibleApiService) NftDeployErc721(ctx context.Context, body NftDeployBody, localVarOptionals *NFTERC721OrCompatibleApiNftDeployErc721Opts) (InlineResponse2005, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2005
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/nft/deploy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2005
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v InlineResponse40311
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NFTERC721OrCompatibleApiService Get the NFTs from a specific smart contract that a blockchain address holds
&lt;p&gt;&lt;b&gt;1 credit per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Get the NFTs minted on a specific smart contract (the &lt;code&gt;contractAddress&lt;/code&gt; path parameter in the request endpoint URL) that a blockchain address holds.&lt;/p&gt; &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; This API works only for the NFT smart contracts deployed using the &lt;a href&#x3D;\&quot;https://apidoc.tatum.io/tag/NFT-(ERC-721-or-compatible)#operation/NftDeployErc721\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum smart contract API&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Flow&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;li&gt;Solana&lt;/li&gt; &lt;li&gt;TRON&lt;/li&gt; &lt;li&gt;Algorand&lt;/li&gt; &lt;/ul&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param chain Blockchain to work with
 * @param address The blockchain address that you want to get the token balance of
 * @param contractAddress The address of the NFT smart contract
 * @param optional nil or *NFTERC721OrCompatibleApiNftGetBalanceErc721Opts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.
@return []string
*/

type NFTERC721OrCompatibleApiNftGetBalanceErc721Opts struct {
    XTestnetType optional.String
}

func (a *NFTERC721OrCompatibleApiService) NftGetBalanceErc721(ctx context.Context, chain string, address string, contractAddress string, localVarOptionals *NFTERC721OrCompatibleApiNftGetBalanceErc721Opts) ([]string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/nft/balance/{chain}/{contractAddress}/{address}"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", fmt.Sprintf("%v", chain), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"address"+"}", fmt.Sprintf("%v", address), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contractAddress"+"}", fmt.Sprintf("%v", contractAddress), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v Error403Celo
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NFTERC721OrCompatibleApiService Get NFT metadata
&lt;p&gt;&lt;b&gt;1 credit per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Get NFT token metadata.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Flow&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;li&gt;TRON&lt;/li&gt; &lt;/ul&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param chain Blockchain to work with
 * @param contractAddress NFT contract address
 * @param token Token ID, required for all except SOL
 * @param optional nil or *NFTERC721OrCompatibleApiNftGetMetadataErc721Opts - Optional Parameters:
     * @param "Account" (optional.String) -  Account holding this token. FLOW only.
     * @param "XTestnetType" (optional.String) -  Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.
@return InlineResponse20043
*/

type NFTERC721OrCompatibleApiNftGetMetadataErc721Opts struct {
    Account optional.String
    XTestnetType optional.String
}

func (a *NFTERC721OrCompatibleApiService) NftGetMetadataErc721(ctx context.Context, chain string, contractAddress string, token string, localVarOptionals *NFTERC721OrCompatibleApiNftGetMetadataErc721Opts) (InlineResponse20043, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse20043
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/nft/metadata/{chain}/{contractAddress}/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", fmt.Sprintf("%v", chain), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contractAddress"+"}", fmt.Sprintf("%v", contractAddress), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", fmt.Sprintf("%v", token), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(token) > 32 {
		return localVarReturnValue, nil, reportError("token must have less than 32 elements")
	}

	if localVarOptionals != nil && localVarOptionals.Account.IsSet() {
		localVarQueryParams.Add("account", parameterToString(localVarOptionals.Account.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse20043
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v Error403Celo
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NFTERC721OrCompatibleApiService Get NFT provenance data
&lt;p&gt;&lt;b&gt;1 credit per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Get NFT token provenance data, valid only for provenance contract.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;/ul&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param chain Blockchain to work with
 * @param tokenId Token ID
 * @param contractAddress NFT contract address
 * @param optional nil or *NFTERC721OrCompatibleApiNftGetProvenanceDataErc721Opts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.
@return []InlineResponse20042
*/

type NFTERC721OrCompatibleApiNftGetProvenanceDataErc721Opts struct {
    XTestnetType optional.String
}

func (a *NFTERC721OrCompatibleApiService) NftGetProvenanceDataErc721(ctx context.Context, chain string, tokenId string, contractAddress string, localVarOptionals *NFTERC721OrCompatibleApiNftGetProvenanceDataErc721Opts) ([]InlineResponse20042, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InlineResponse20042
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/nft/provenance/{chain}/{contractAddress}/{tokenId}"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", fmt.Sprintf("%v", chain), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tokenId"+"}", fmt.Sprintf("%v", tokenId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contractAddress"+"}", fmt.Sprintf("%v", contractAddress), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(tokenId) > 32 {
		return localVarReturnValue, nil, reportError("tokenId must have less than 32 elements")
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InlineResponse20042
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v Error403
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NFTERC721OrCompatibleApiService Get NFT royalty information
&lt;p&gt;&lt;b&gt;1 credit per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Get NFT token royalty.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Flow&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;li&gt;TRON&lt;/li&gt; &lt;/ul&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param chain Blockchain to work with
 * @param contractAddress NFT contract address
 * @param token Token ID, required for all except SOL
 * @param optional nil or *NFTERC721OrCompatibleApiNftGetRoyaltyErc721Opts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.
@return InlineResponse20044
*/

type NFTERC721OrCompatibleApiNftGetRoyaltyErc721Opts struct {
    XTestnetType optional.String
}

func (a *NFTERC721OrCompatibleApiService) NftGetRoyaltyErc721(ctx context.Context, chain string, contractAddress string, token string, localVarOptionals *NFTERC721OrCompatibleApiNftGetRoyaltyErc721Opts) (InlineResponse20044, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse20044
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/nft/royalty/{chain}/{contractAddress}/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", fmt.Sprintf("%v", chain), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contractAddress"+"}", fmt.Sprintf("%v", contractAddress), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", fmt.Sprintf("%v", token), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(token) > 32 {
		return localVarReturnValue, nil, reportError("token must have less than 32 elements")
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse20044
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v Error403Celo
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NFTERC721OrCompatibleApiService Get all NFTs that a blockchain address holds
&lt;p&gt;&lt;b&gt;1 credit per API call + 5 credits for each owned NFT&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Get all NFTs that a blockchain address holds. The NFTs are returned grouped by the smart contracts they were minted on.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Algorand&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;li&gt;Solana&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;On Solana and Algorand, if a blockchain address holds fewer than 50 NFTs, the API also returns each NFT&#x27;s metadata. If the metadata is not returned, you can obtain it using the &lt;a href&#x3D;\&quot;https://apidoc.tatum.io/tag/NFT-(ERC-721-or-compatible)/#operation/NftGetMetadataErc721\&quot;&gt;API for getting NFT metadata&lt;/a&gt;.&lt;/p&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param chain Blockchain to work with
 * @param address The blockchain address that you want to get the token balance of
@return []InlineResponse20040
*/
func (a *NFTERC721OrCompatibleApiService) NftGetTokensByAddressErc721(ctx context.Context, chain string, address string) ([]InlineResponse20040, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InlineResponse20040
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/nft/address/balance/{chain}/{address}"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", fmt.Sprintf("%v", chain), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"address"+"}", fmt.Sprintf("%v", address), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InlineResponse20040
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v Error403
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NFTERC721OrCompatibleApiService Get NFTs from a collection
&lt;p&gt;&lt;b&gt;1 credit per API call + 5 credits for each listed NFT&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Get all minted NFTs in the collection. Returns all NFTs this contract minted.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;/ul&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param chain Blockchain to work with
 * @param pageSize Max number of items per page is 50.
 * @param address Collection address
 * @param optional nil or *NFTERC721OrCompatibleApiNftGetTokensByCollectionErc721Opts - Optional Parameters:
     * @param "Offset" (optional.Float64) -  Offset to obtain next page of the data.
@return []InlineResponse20041
*/

type NFTERC721OrCompatibleApiNftGetTokensByCollectionErc721Opts struct {
    Offset optional.Float64
}

func (a *NFTERC721OrCompatibleApiService) NftGetTokensByCollectionErc721(ctx context.Context, chain string, pageSize float64, address string, localVarOptionals *NFTERC721OrCompatibleApiNftGetTokensByCollectionErc721Opts) ([]InlineResponse20041, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InlineResponse20041
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/nft/collection/{chain}/{address}"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", fmt.Sprintf("%v", chain), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"address"+"}", fmt.Sprintf("%v", address), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if pageSize < 1 {
		return localVarReturnValue, nil, reportError("pageSize must be greater than 1")
	}
	if pageSize > 50 {
		return localVarReturnValue, nil, reportError("pageSize must be less than 50")
	}

	localVarQueryParams.Add("pageSize", parameterToString(pageSize, ""))
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InlineResponse20041
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v Error403
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NFTERC721OrCompatibleApiService Get an NFT transaction by its hash
&lt;p&gt;&lt;b&gt;1 credit per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Get NFT transaction by transaction hash.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Flow&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;li&gt;TRON&lt;/li&gt; &lt;/ul&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param chain Blockchain to work with
 * @param hash Transaction hash
 * @param optional nil or *NFTERC721OrCompatibleApiNftGetTransactErc721Opts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.
@return InlineResponse20039
*/

type NFTERC721OrCompatibleApiNftGetTransactErc721Opts struct {
    XTestnetType optional.String
}

func (a *NFTERC721OrCompatibleApiService) NftGetTransactErc721(ctx context.Context, chain string, hash string, localVarOptionals *NFTERC721OrCompatibleApiNftGetTransactErc721Opts) (InlineResponse20039, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse20039
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/nft/transaction/{chain}/{hash}"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", fmt.Sprintf("%v", chain), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hash"+"}", fmt.Sprintf("%v", hash), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse20039
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v InlineResponse4039
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NFTERC721OrCompatibleApiService Get NFT transactions on a blockchain address
&lt;p&gt;&lt;b&gt;1 credit per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Get incoming and outgoing NFT transactions on a blockchain address.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;/ul&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param chain Blockchain to work with
 * @param address Account address you want to get balance of
 * @param tokenAddress Address of the token smart contract
 * @param pageSize Max number of items per page is 50.
 * @param optional nil or *NFTERC721OrCompatibleApiNftGetTransactionByAddressOpts - Optional Parameters:
     * @param "Offset" (optional.Float64) -  Offset to obtain next page of the data.
     * @param "From" (optional.Float64) -  Transactions from this block onwords will be included.
     * @param "To" (optional.Float64) -  Transactions up to this block will be included.
@return []Object
*/

type NFTERC721OrCompatibleApiNftGetTransactionByAddressOpts struct {
    Offset optional.Float64
    From optional.Float64
    To optional.Float64
}

func (a *NFTERC721OrCompatibleApiService) NftGetTransactionByAddress(ctx context.Context, chain string, address string, tokenAddress string, pageSize float64, localVarOptionals *NFTERC721OrCompatibleApiNftGetTransactionByAddressOpts) ([]Object, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Object
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/nft/transaction/{chain}/{address}/{tokenAddress}"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", fmt.Sprintf("%v", chain), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"address"+"}", fmt.Sprintf("%v", address), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tokenAddress"+"}", fmt.Sprintf("%v", tokenAddress), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if pageSize < 1 {
		return localVarReturnValue, nil, reportError("pageSize must be greater than 1")
	}
	if pageSize > 50 {
		return localVarReturnValue, nil, reportError("pageSize must be less than 50")
	}

	localVarQueryParams.Add("pageSize", parameterToString(pageSize, ""))
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.From.IsSet() {
		localVarQueryParams.Add("from", parameterToString(localVarOptionals.From.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.To.IsSet() {
		localVarQueryParams.Add("to", parameterToString(localVarOptionals.To.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Object
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NFTERC721OrCompatibleApiService Get NFT transactions for an NFT
&lt;p&gt;&lt;b&gt;1 credit per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Get NFT transactions by token. This includes incoming and outgoing transactions for the token.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;/ul&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param chain Blockchain to work with
 * @param tokenId NFT Token ID
 * @param tokenAddress Address of the token smart contract
 * @param pageSize Max number of items per page is 50.
 * @param optional nil or *NFTERC721OrCompatibleApiNftGetTransactionByTokenOpts - Optional Parameters:
     * @param "Offset" (optional.Float64) -  Offset to obtain next page of the data.
     * @param "From" (optional.Float64) -  Transactions from this block onwords will be included.
     * @param "To" (optional.Float64) -  Transactions up to this block will be included.
@return []Object
*/

type NFTERC721OrCompatibleApiNftGetTransactionByTokenOpts struct {
    Offset optional.Float64
    From optional.Float64
    To optional.Float64
}

func (a *NFTERC721OrCompatibleApiService) NftGetTransactionByToken(ctx context.Context, chain string, tokenId int32, tokenAddress string, pageSize float64, localVarOptionals *NFTERC721OrCompatibleApiNftGetTransactionByTokenOpts) ([]Object, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Object
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/nft/transaction/tokenId/{chain}/{tokenAddress}/{tokenId}"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", fmt.Sprintf("%v", chain), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tokenId"+"}", fmt.Sprintf("%v", tokenId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tokenAddress"+"}", fmt.Sprintf("%v", tokenAddress), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if tokenId < 0 {
		return localVarReturnValue, nil, reportError("tokenId must be greater than 0")
	}
	if pageSize < 1 {
		return localVarReturnValue, nil, reportError("pageSize must be greater than 1")
	}
	if pageSize > 50 {
		return localVarReturnValue, nil, reportError("pageSize must be less than 50")
	}

	localVarQueryParams.Add("pageSize", parameterToString(pageSize, ""))
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.From.IsSet() {
		localVarQueryParams.Add("from", parameterToString(localVarOptionals.From.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.To.IsSet() {
		localVarQueryParams.Add("to", parameterToString(localVarOptionals.To.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Object
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NFTERC721OrCompatibleApiService Mint an NFT
&lt;p&gt;&lt;b&gt;100 credits per API call on Flow&lt;br/&gt; 2 credits per API call on the other blockchains&lt;/b&gt;&lt;/p&gt; &lt;p&gt;You can mint NFTs using either of the following methods:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#NftExpress\&quot;&gt;Using NFT Express&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#NftNative\&quot;&gt;Natively on a blockchain&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h3 id&#x3D;\&quot;NftExpress\&quot;&gt;Minting NFTs using NFT Express&lt;/h3&gt; &lt;p&gt;NFT Express is Tatum&#x27;s feature that helps you mint NFTs easier than minting natively on a blockchain.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;b&gt;You do not need to enter your private key or signature ID.&lt;/b&gt;&lt;br/&gt;NFT Express uses the private key provided by Tatum.&lt;/li&gt; &lt;li&gt;&lt;b&gt;You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions.&lt;/b&gt; &lt;ul&gt; &lt;li&gt;To use NFT Express on the &lt;b&gt;mainnet&lt;/b&gt;, you have to have a &lt;a href&#x3D;\&quot;https://tatum.io/pricing\&quot; target&#x3D;\&quot;_blank\&quot;&gt;paid pricing plan&lt;/a&gt;.&lt;br/&gt;Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan.&lt;br/&gt;The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on.&lt;/li&gt; &lt;li&gt;On the &lt;b&gt;testnet&lt;/b&gt;, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan.&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;With NFT Express, you can choose whether to mint NFTs on the &lt;a href&#x3D;\&quot;#NftExpressPrebuilt\&quot;&gt;pre-built NFT smart contract provided by Tatum&lt;/a&gt; or on &lt;a href&#x3D;\&quot;#NftExpressOwn\&quot;&gt;your own smart contract&lt;/a&gt;.&lt;/p&gt; &lt;h4 id&#x3D;\&quot;NftExpressPrebuilt\&quot;&gt;Minting NFTs using the pre-built smart contract provided by Tatum&lt;/h4&gt; &lt;p&gt;If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum.&lt;br/&gt;The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet.&lt;/p&gt; &lt;p&gt;You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Algorand&lt;/li&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;li&gt;Solana&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Depending on what blockchain you use, choose the request body schema to use in the API call.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;To mint NFTs on &lt;b&gt;BNB Smart Chain&lt;/b&gt;, &lt;b&gt;Celo&lt;/b&gt;, &lt;b&gt;Ethereum&lt;/b&gt;, &lt;b&gt;Harmony&lt;/b&gt;, &lt;b&gt;Klaytn&lt;/b&gt;, or &lt;b&gt;Polygon&lt;/b&gt;, use this API with the &lt;code&gt;MintNftExpress&lt;/code&gt; schema of the request body.&lt;/li&gt; &lt;li&gt;To mint NFTs on &lt;b&gt;Algorand&lt;/b&gt;, use this API with the &lt;code&gt;MintNftExpressAlgorand&lt;/code&gt; schema of the request body.&lt;br/&gt;An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#x27;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed.&lt;br/&gt;This how it works: &lt;ol&gt; &lt;li&gt;The recipient &lt;a href&#x3D;\&quot;https://apidoc.tatum.io/tag/Algorand#operation/AlgorandBlockchainReceiveAsset\&quot; target&#x3D;\&quot;_blank\&quot;&gt;agrees to receive the NFT&lt;/a&gt; to their address.&lt;/li&gt; &lt;li&gt;You &lt;a href&#x3D;\&quot;#operation/NftTransferErc721\&quot;&gt;transfer the NFT&lt;/a&gt; to the recipient&#x27;s address (use the &lt;code&gt;transferNftAlgoExpress&lt;/code&gt; schema of the request body).&lt;br /&gt;&lt;b&gt;NOTE:&lt;/b&gt; On the &lt;b&gt;mainnet&lt;/b&gt;, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the &lt;b&gt;testnet&lt;/b&gt;, no credits are deducted from the monthly credit allowance.&lt;/li&gt; &lt;/ol&gt;&lt;/li&gt; &lt;li&gt;To mint NFTs on &lt;b&gt;Solana&lt;/b&gt;, use this API with the &lt;code&gt;MintNftExpressSolana&lt;/code&gt; schema of the request body.&lt;br/&gt;Solana uses the &lt;a href&#x3D;\&quot;https://www.metaplex.com/\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Metaplex Protocol&lt;/a&gt;, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used.&lt;br/&gt;When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#x27;s account address (the one in the &lt;code&gt;to&lt;/code&gt; parameter of the request body). This address is returned in the &lt;code&gt;nftAccountAddress&lt;/code&gt; parameter in the response body, is owned by the recipient&#x27;s address, and has the same private key.&lt;br/&gt;The response body also returns the address of the minted NFT itself, which is held in the &lt;code&gt;nftAddress&lt;/code&gt; parameter.&lt;br/&gt;After the NFT is minted, you have to &lt;a href&#x3D;\&quot;#operation/NftTransferErc721\&quot;&gt;transfer it&lt;/a&gt; to the recipient&#x27;s address (use the &lt;code&gt;transferNftSolana&lt;/code&gt; or &lt;code&gt;transferNftSolanaKMS&lt;/code&gt; schema of the request body). In the request body: &lt;ul&gt; &lt;li&gt;Set the &lt;code&gt;contractAddress&lt;/code&gt; parameter to the address from the &lt;code&gt;nftAddress&lt;/code&gt; parameter in the response body of the minting call.&lt;/li&gt; &lt;li&gt;Set both &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; parameters to the recipient&#x27;s address from the &lt;code&gt;to&lt;/code&gt; parameter in the response body of the minting call.&lt;/li&gt; &lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt; &lt;h4 id&#x3D;\&quot;NftExpressOwn\&quot;&gt;Minting NFTs with NFT Express using your own smart contract&lt;/h4&gt; &lt;p&gt;If you want to mint NFTs using your own smart contract, you are going to use an &lt;b&gt;NTF minter&lt;/b&gt;, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan.&lt;br/&gt; &lt;p&gt;You can mint NFTs on your own smart contract on the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;To mint NFTs using your own smart contract, do the following:&lt;/p&gt; &lt;ol&gt; &lt;li&gt;In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet).&lt;/li&gt; &lt;li&gt;&lt;a href&#x3D;\&quot;#operation/NftAddMinter\&quot;&gt;Add the minter address as an NFT minter to your smart contract&lt;/a&gt;.&lt;/li&gt; &lt;li&gt;Use this API with the &lt;code&gt;MintNftMinter&lt;/code&gt; schema of the request body.&lt;br /&gt;In the request body, enter the following information: &lt;ul&gt; &lt;li&gt;&lt;code&gt;chain&lt;/code&gt; is the blockchain that you use.&lt;/li&gt; &lt;li&gt;&lt;code&gt;to&lt;/code&gt; is the blockchain address where to send the minted NFT to.&lt;/li&gt; &lt;li&gt;&lt;code&gt;url&lt;/code&gt; is the URL of the NFT metadata.&lt;/li&gt; &lt;li&gt;&lt;code&gt;minter&lt;/code&gt; is the address of the NFT minter that you found in Step 1.&lt;/li&gt; &lt;li&gt;&lt;code&gt;contractAddress&lt;/code&gt; is the address of your NFT smart contract.&lt;/li&gt; &lt;li&gt;&lt;code&gt;tokenId&lt;/code&gt; is the the token ID of the NFT.&lt;br /&gt;For example: &lt;pre&gt; {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } &lt;/pre&gt; When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically: &lt;pre&gt; {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } &lt;/pre&gt;                                &lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;/ol&gt; &lt;p&gt;The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains:&lt;/p&gt; &lt;table&gt;   &lt;tr&gt;     &lt;th&gt;Blockchain&lt;/th&gt;     &lt;th&gt;Minter address - testnet*&lt;/th&gt;     &lt;th&gt;Minter address - mainnet&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;BNB Smart Chain&lt;/td&gt;     &lt;td&gt;0xc16ae5e8c985b906935a0cadf4e24f0400531883&lt;/td&gt;     &lt;td&gt;0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Celo&lt;/td&gt;     &lt;td&gt;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F&lt;/td&gt;     &lt;td&gt;0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Ethereum&lt;/td&gt;     &lt;td&gt;0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848&lt;/td&gt;     &lt;td&gt;0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Harmony&lt;/td&gt;     &lt;td&gt;0x8906f62d40293ddca77fdf6714c3f63265deddf0&lt;/td&gt;     &lt;td&gt;0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Klaytn&lt;/td&gt;     &lt;td&gt;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2&lt;/td&gt;     &lt;td&gt;0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Polygon&lt;/td&gt;     &lt;td&gt;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5&lt;/td&gt;     &lt;td&gt;0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94&lt;/td&gt;   &lt;/tr&gt; &lt;/table&gt; &lt;p&gt;*If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain.&lt;/p&gt; &lt;h3 id&#x3D;\&quot;NftNative\&quot;&gt;Minting NFTs natively on a blockchain&lt;/h3&gt; &lt;p&gt;When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.&lt;/p&gt; &lt;p&gt;Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the &lt;b&gt;testnet&lt;/b&gt; of a blockchain.&lt;/p&gt; &lt;p&gt;For signing transactions on the &lt;b&gt;mainnet&lt;/b&gt;, we strongly recommend that you use the Tatum &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Key Management System (KMS)&lt;/a&gt; and provide the signature ID instead of the private key in the API. Alternatively, you can use the &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-js\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum JavaScript client&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;You can mint NFTs natively on the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Algorand&lt;/li&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Flow&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;li&gt;Solana&lt;/li&gt; &lt;li&gt;TRON&lt;/li&gt; &lt;/ul&gt;         &lt;p&gt;Depending on what blockchain you use, choose the request body schema to use in the API call.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;To mint NFTs natively on &lt;b&gt;Algorand&lt;/b&gt; and: &lt;ul&gt;&lt;li&gt;To sign the transaction with your &lt;b&gt;private key&lt;/b&gt;, use this API with the &lt;code&gt;MintNftAlgorand&lt;/code&gt; schema of the request body.&lt;/li&gt; &lt;li&gt;To sign the transaction with your &lt;b&gt;signature ID&lt;/b&gt;, use this API the &lt;code&gt;MintNftAlgorandKMS&lt;/code&gt; schema of the request body.&lt;br/&gt;&lt;b&gt;NOTE:&lt;/b&gt; An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#x27;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the &lt;a href&#x3D;\&quot;#NftExpressPrebuilt\&quot;&gt;pre-built NFT smart contract provided by Tatum&lt;/a&gt;.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;To mint NFTs natively on &lt;b&gt;BNB Smart Chain&lt;/b&gt;, &lt;b&gt;Ethereum&lt;/b&gt;, &lt;b&gt;Harmony&lt;/b&gt;, &lt;b&gt;Klaytn&lt;/b&gt;, &lt;b&gt;KuCoin Community Chain&lt;/b&gt;, or &lt;b&gt;Polygon&lt;/b&gt;, and: &lt;ul&gt;&lt;li&gt;To sign the transaction with your &lt;b&gt;private key&lt;/b&gt;, use this API with the &lt;code&gt;MintNft&lt;/code&gt; schema of the request body.&lt;/li&gt; &lt;li&gt;To sign the transaction with your &lt;b&gt;signature ID&lt;/b&gt;, use this API the &lt;code&gt;MintNftKMS&lt;/code&gt; schema of the request body.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;To mint NFTs natively on &lt;b&gt;Celo&lt;/b&gt; and: &lt;ul&gt;&lt;li&gt;To sign the transaction with your &lt;b&gt;private key&lt;/b&gt;, use this API with the &lt;code&gt;MintNftCelo&lt;/code&gt; schema of the request body.&lt;/li&gt; &lt;li&gt;To sign the transaction with your &lt;b&gt;signature ID&lt;/b&gt;, use this API the &lt;code&gt;MintNftKMSCelo&lt;/code&gt; schema of the request body.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;To mint NFTs natively on &lt;b&gt;Flow&lt;/b&gt; and: &lt;ul&gt;&lt;li&gt;To sign the transaction with your &lt;b&gt;private key&lt;/b&gt;, use this API with the &lt;code&gt;MintNftFlowPK&lt;/code&gt; schema of the request body.&lt;/li&gt; &lt;li&gt;To sign the transaction with your &lt;b&gt;signature ID&lt;/b&gt;, use this API the &lt;code&gt;MintNftFlowMnemonic&lt;/code&gt; schema of the request body.&lt;/li&gt; &lt;li&gt;To sign the transaction with your &lt;b&gt;wallet mnemonic&lt;/b&gt;, use this API the &lt;code&gt;MintNftFlowKMS&lt;/code&gt; schema of the request body.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;To mint NFTs natively on &lt;b&gt;Solana&lt;/b&gt; and: &lt;ul&gt;&lt;li&gt;To sign the transaction with your &lt;b&gt;private key&lt;/b&gt;, use this API with the &lt;code&gt;MintNftSolana&lt;/code&gt; schema of the request body.&lt;/li&gt; &lt;li&gt;To sign the transaction with your &lt;b&gt;signature ID&lt;/b&gt;, use this API the &lt;code&gt;MintNftSolanaKMS&lt;/code&gt; schema of the request body.&lt;br/&gt;&lt;b&gt;NOTE:&lt;/b&gt; When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#x27;s account address. After the NFT is minted, you have to transfer it to the recipient&#x27;s address. For more information about how it works, see the section about minting NFTs on Solana using the &lt;a href&#x3D;\&quot;#NftExpressPrebuilt\&quot;&gt;pre-built NFT smart contract provided by Tatum&lt;/a&gt;.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;To mint NFTs natively on &lt;b&gt;TRON&lt;/b&gt; and: &lt;ul&gt;&lt;li&gt;To sign the transaction with your &lt;b&gt;private key&lt;/b&gt;, use this API with the &lt;code&gt;MintNftTron&lt;/code&gt; schema of the request body.&lt;/li&gt; &lt;li&gt;To sign the transaction with your &lt;b&gt;signature ID&lt;/b&gt;, use this API the &lt;code&gt;MintNftKMSTron&lt;/code&gt; schema of the request body.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;/ul&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *NFTERC721OrCompatibleApiNftMintErc721Opts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.
@return InlineResponse20037
*/

type NFTERC721OrCompatibleApiNftMintErc721Opts struct {
    XTestnetType optional.String
}

func (a *NFTERC721OrCompatibleApiService) NftMintErc721(ctx context.Context, body NftMintBody, localVarOptionals *NFTERC721OrCompatibleApiNftMintErc721Opts) (InlineResponse20037, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse20037
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/nft/mint"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse20037
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v InlineResponse40366
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NFTERC721OrCompatibleApiService Mint multiple NFTs
&lt;p&gt;&lt;b&gt;100 credits per API call on Flow&lt;br/&gt; 2 credits per API call on the other blockchains&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Flow&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;li&gt;TRON&lt;/li&gt; &lt;/ul&gt; This operation works in two modes.  First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#x27;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum KMS&lt;/a&gt; should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages.  Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#x27;t specify private key or signatureId, only minter address, from which the NFT will be minted.&lt;br/&gt; It means you perform mint multiple NFT request with following body: &lt;pre&gt;{    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; }&lt;/pre&gt; The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debitted in form of credits. The credits are debitted only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: &lt;pre&gt;mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean&lt;/pre&gt; You can use addresses specified in the bellow table to be used as a minter. &lt;table&gt;   &lt;tr&gt;     &lt;th&gt;Chain&lt;/th&gt;     &lt;th&gt;Testnet address&lt;/th&gt;     &lt;th&gt;Mainnet Address&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;MATIC&lt;/td&gt;     &lt;td&gt;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5&lt;/td&gt;     &lt;td&gt;0xcf9e127455d28e7362380aec1b92ddee8200b295&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;BSC&lt;/td&gt;     &lt;td&gt;0xc16ae5e8c985b906935a0cadf4e24f0400531883&lt;/td&gt;     &lt;td&gt;0xcf9e127455d28e7362380aec1b92ddee8200b295&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;ONE&lt;/td&gt;     &lt;td&gt;0x8906f62d40293ddca77fdf6714c3f63265deddf0&lt;/td&gt;     &lt;td&gt;0xcf9e127455d28e7362380aec1b92ddee8200b295&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;ETH&lt;/td&gt;     &lt;td&gt;0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848&lt;/td&gt;     &lt;td&gt;0xcf9e127455d28e7362380aec1b92ddee8200b295&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;CELO&lt;/td&gt;     &lt;td&gt;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F&lt;/td&gt;     &lt;td&gt;0xcf9e127455d28e7362380aec1b92ddee8200b295&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;KLAY&lt;/td&gt;     &lt;td&gt;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2&lt;/td&gt;     &lt;td&gt;0xcf9e127455d28e7362380aec1b92ddee8200b295&lt;/td&gt;   &lt;/tr&gt; &lt;/table&gt; If there are not enough coins on any testnet address, feel free to send coins there.&lt;/p&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *NFTERC721OrCompatibleApiNftMintMultipleErc721Opts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.
@return InlineResponse20038
*/

type NFTERC721OrCompatibleApiNftMintMultipleErc721Opts struct {
    XTestnetType optional.String
}

func (a *NFTERC721OrCompatibleApiService) NftMintMultipleErc721(ctx context.Context, body MintBatchBody, localVarOptionals *NFTERC721OrCompatibleApiNftMintMultipleErc721Opts) (InlineResponse20038, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse20038
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/nft/mint/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse20038
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v InlineResponse40366
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NFTERC721OrCompatibleApiService Transfer an NFT
&lt;p&gt;&lt;b&gt;100 credits per API call on Flow&lt;br/&gt; 2 credits per API call on the other blockchains&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Transfer an NFT from the smart contract (the &lt;code&gt;contractAddress&lt;/code&gt; parameter in the request body) to the specified blockchain address (the &lt;code&gt;to&lt;/code&gt; parameter in the request body).&lt;/p&gt; &lt;p&gt;In one API call, you can transfer only one NFT.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Algorand&lt;/li&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Flow&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;li&gt;Solana&lt;/li&gt; &lt;li&gt;TRON&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;For Ethereum, Celo, and BNB Smart Chain, transferring NFTs invokes the &lt;code&gt;safeTransfer()&lt;/code&gt; method.&lt;/p&gt; &lt;p&gt;&lt;b&gt;Transferring NFTs on Algorand&lt;/p&gt;&lt;/b&gt; &lt;ul&gt; &lt;li&gt;On Algorand, the recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. Before transferring an NFT, make sure that the recipient &lt;a href&#x3D;\&quot;https://apidoc.tatum.io/tag/Algorand#operation/AlgorandBlockchainReceiveAsset\&quot; target&#x3D;\&quot;_blank\&quot;&gt;has agreed to receive the NFT&lt;/a&gt; to their address.&lt;/li&gt; &lt;li&gt;If you want to transfer an NFT that &lt;a href&#x3D;\&quot;#operation/NftMintErc721\&quot;&gt;was minted using NFT Express&lt;/a&gt;, use the &lt;code&gt;transferNftAlgoExpress&lt;/code&gt; schema of the request body.&lt;br /&gt;&lt;b&gt;NOTE:&lt;/b&gt; On the &lt;b&gt;mainnet&lt;/b&gt;, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the &lt;b&gt;testnet&lt;/b&gt;, no credits are deducted from the monthly credit allowance.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;b&gt;Transferring NFTs on Solana&lt;/p&gt;&lt;/b&gt; &lt;p&gt;If you want to transfer an NFT that &lt;a href&#x3D;\&quot;#operation/NftMintErc721\&quot;&gt;was minted using NFT Express&lt;/a&gt;, see the section about minting NFTs on Solana using the &lt;a href&#x3D;\&quot;#operation/NftMintErc721\&quot;&gt;pre-built NFT smart contract provided by Tatum&lt;/a&gt; for the information about how to set up the parameters in the request body.&lt;/p&gt; &lt;p&gt;&lt;b&gt;Signing a transaction&lt;/b&gt;&lt;/p&gt; &lt;p&gt;When transferring an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.&lt;/p&gt; &lt;p&gt;Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the &lt;b&gt;testnet&lt;/b&gt; of a blockchain.&lt;/p&gt; &lt;p&gt;For signing transactions on the &lt;b&gt;mainnet&lt;/b&gt;, we strongly recommend that you use the Tatum &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Key Management System (KMS)&lt;/a&gt; and provide the signature ID instead of the private key in the API. Alternatively, you can use the &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-js\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum JavaScript client&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; This does not apply to transferring NFTs that were minted on Algorand using NFT Express (see earlier in this section).&lt;/p&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *NFTERC721OrCompatibleApiNftTransferErc721Opts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.
@return InlineResponse2005
*/

type NFTERC721OrCompatibleApiNftTransferErc721Opts struct {
    XTestnetType optional.String
}

func (a *NFTERC721OrCompatibleApiService) NftTransferErc721(ctx context.Context, body NftTransactionBody, localVarOptionals *NFTERC721OrCompatibleApiNftTransferErc721Opts) (InlineResponse2005, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2005
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/nft/transaction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2005
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v InlineResponse40366
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NFTERC721OrCompatibleApiService Update NFT royalty
&lt;p&gt;&lt;b&gt;2 credits per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Update royalty cashback value for one NFT Token. This method updates the first royalty value of specific author for 1 token. If royalty value is set to 0, it will disable the royalty system for the token. Only from author&#x27;s address of the royalty can change it&#x27;s royalty value, not the owner of the token.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;li&gt;TRON&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;b&gt;Signing a transaction&lt;/b&gt;&lt;/p&gt; &lt;p&gt;When updating NFT royalty, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.&lt;/p&gt; &lt;p&gt;Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the &lt;b&gt;testnet&lt;/b&gt; of a blockchain.&lt;/p&gt; &lt;p&gt;For signing transactions on the &lt;b&gt;mainnet&lt;/b&gt;, we strongly recommend that you use the Tatum &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Key Management System (KMS)&lt;/a&gt; and provide the signature ID instead of the private key in the API. Alternatively, you can use the &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-js\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum JavaScript client&lt;/a&gt;.&lt;/p&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *NFTERC721OrCompatibleApiNftUpdateCashbackErc721Opts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.
@return InlineResponse2005
*/

type NFTERC721OrCompatibleApiNftUpdateCashbackErc721Opts struct {
    XTestnetType optional.String
}

func (a *NFTERC721OrCompatibleApiService) NftUpdateCashbackErc721(ctx context.Context, body NftRoyaltyBody, localVarOptionals *NFTERC721OrCompatibleApiNftUpdateCashbackErc721Opts) (InlineResponse2005, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2005
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/nft/royalty"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2005
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v InlineResponse40366
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NFTERC721OrCompatibleApiService Verify an NFT in an NFT collection on Solana
&lt;p&gt;&lt;b&gt;2 credits per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Verify an NFT in an NFT collection on Solana. Verifying an NFT sets the &lt;code&gt;Verified&lt;/code&gt; parameter to &lt;code&gt;true&lt;/code&gt; for the NFT, which means that the NFT is really a part of the collection. To know more about Solana collections and verification, refer to the &lt;a href&#x3D;\&quot;https://docs.metaplex.com/programs/token-metadata/certified-collections\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Solana user documentation&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;The collection must be a sized collection that was introduced in &lt;a href&#x3D;\&quot;https://docs.metaplex.com/programs/token-metadata/changelog/v1.3\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Version 1.3&lt;/a&gt; of the Metaplex Token Metadata program. The NFT must have been &lt;a href&#x3D;\&quot;#operation/NftMintErc721\&quot;&gt;minted in this collection&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;This API is supported only for Solana.&lt;/p&gt; &lt;p&gt;&lt;b&gt;Signing a transaction&lt;/b&gt;&lt;/p&gt; &lt;p&gt;When verifying an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.&lt;/p&gt; &lt;p&gt;Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the &lt;b&gt;testnet&lt;/b&gt; of a blockchain.&lt;/p&gt; &lt;p&gt;For signing transactions on the &lt;b&gt;mainnet&lt;/b&gt;, we strongly recommend that you use the Tatum &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Key Management System (KMS)&lt;/a&gt; and provide the signature ID instead of the private key in the API. Alternatively, you can use the &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-js\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum JavaScript client&lt;/a&gt;.&lt;/p&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
@return InlineResponse2005
*/
func (a *NFTERC721OrCompatibleApiService) NftVerifyInCollection(ctx context.Context, body NftVerifyBody) (InlineResponse2005, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2005
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/nft/verify"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2005
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v InlineResponse40311
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
