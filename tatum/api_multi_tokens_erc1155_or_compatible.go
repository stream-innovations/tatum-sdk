
/*
 * Tatum API Reference
 *
 * # Welcome to the Tatum API Reference!  ## What is Tatum? ## What is Tatum?  Tatum offers a flexible framework to build, run, and scale blockchain apps fast. To learn more about the Tatum blockchain development framework, visit [our website](https://tatum.io/framework).  The Tatum API features powerful endpoints that simplify a complex blockchain into single API requests. Code for all supported blockchains using unified API calls.  ## Need help?  To chat with other developers, get help from the Support team, and engage with the thriving Tatum community, join  our [Discord server](https://discord.com/invite/tatum). For more information about how to work with Tatum, review the [online documentation](https://docs.tatum.io/).  ## About this API Reference  The Tatum API Reference is based on OpenAPI Specification v3.1.0 with a few [vendor extensions](https://github.com/Redocly/redoc/blob/master/docs/redoc-vendor-extensions.md) applied.  # Authentication  When using the Tatum API, you authenticate yourself with an **API key**. <SecurityDefinitions /> 
 *
 * API version: 3.16.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package tatum

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type MultiTokensERC1155OrCompatibleApiService service
/*
MultiTokensERC1155OrCompatibleApiService Add a Multi Token minter
&lt;p&gt;&lt;b&gt;2 credits per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Add Multi Token minter.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;b&gt;Signing a transaction&lt;/b&gt;&lt;/p&gt; &lt;p&gt;When adding a Multi Token minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.&lt;/p&gt; &lt;p&gt;Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the &lt;b&gt;testnet&lt;/b&gt; of a blockchain.&lt;/p&gt; &lt;p&gt;For signing transactions on the &lt;b&gt;mainnet&lt;/b&gt;, we strongly recommend that you use the Tatum &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Key Management System (KMS)&lt;/a&gt; and provide the signature ID instead of the private key in the API. Alternatively, you can use the &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-js\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum JavaScript client&lt;/a&gt;.&lt;/p&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *MultiTokensERC1155OrCompatibleApiAddMultiTokenMinterOpts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.
@return InlineResponse2005
*/

type MultiTokensERC1155OrCompatibleApiAddMultiTokenMinterOpts struct {
    XTestnetType optional.String
}

func (a *MultiTokensERC1155OrCompatibleApiService) AddMultiTokenMinter(ctx context.Context, body MintAddBody1, localVarOptionals *MultiTokensERC1155OrCompatibleApiAddMultiTokenMinterOpts) (InlineResponse2005, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2005
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/multitoken/mint/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2005
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v InlineResponse40366
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
MultiTokensERC1155OrCompatibleApiService Burn a Multi Token
&lt;p&gt;&lt;b&gt;2 credits per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Burn a fixed amount of Multi Tokens by id. This method destroys Multi Tokens from smart contract defined in contractAddress.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Algorand&lt;/li&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;b&gt;Signing a transaction&lt;/b&gt;&lt;/p&gt; &lt;p&gt;When burning a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.&lt;/p&gt; &lt;p&gt;Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the &lt;b&gt;testnet&lt;/b&gt; of a blockchain.&lt;/p&gt; &lt;p&gt;For signing transactions on the &lt;b&gt;mainnet&lt;/b&gt;, we strongly recommend that you use the Tatum &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Key Management System (KMS)&lt;/a&gt; and provide the signature ID instead of the private key in the API. Alternatively, you can use the &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-js\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum JavaScript client&lt;/a&gt;.&lt;/p&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *MultiTokensERC1155OrCompatibleApiBurnMultiTokenOpts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.
@return InlineResponse2005
*/

type MultiTokensERC1155OrCompatibleApiBurnMultiTokenOpts struct {
    XTestnetType optional.String
}

func (a *MultiTokensERC1155OrCompatibleApiService) BurnMultiToken(ctx context.Context, body MultitokenBurnBody, localVarOptionals *MultiTokensERC1155OrCompatibleApiBurnMultiTokenOpts) (InlineResponse2005, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2005
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/multitoken/burn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2005
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v InlineResponse40366
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
MultiTokensERC1155OrCompatibleApiService Burn multiple Multi Tokens
&lt;p&gt;&lt;b&gt;2 credits per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Burn multiple Multi Token Tokens by id assigned to same address in one transaction. This method destroys any Multi Tokens token from smart contract defined in contractAddress.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;b&gt;Signing a transaction&lt;/b&gt;&lt;/p&gt; &lt;p&gt;When burning multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.&lt;/p&gt; &lt;p&gt;Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the &lt;b&gt;testnet&lt;/b&gt; of a blockchain.&lt;/p&gt; &lt;p&gt;For signing transactions on the &lt;b&gt;mainnet&lt;/b&gt;, we strongly recommend that you use the Tatum &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Key Management System (KMS)&lt;/a&gt; and provide the signature ID instead of the private key in the API. Alternatively, you can use the &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-js\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum JavaScript client&lt;/a&gt;.&lt;/p&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *MultiTokensERC1155OrCompatibleApiBurnMultiTokenBatchOpts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.
@return InlineResponse2005
*/

type MultiTokensERC1155OrCompatibleApiBurnMultiTokenBatchOpts struct {
    XTestnetType optional.String
}

func (a *MultiTokensERC1155OrCompatibleApiService) BurnMultiTokenBatch(ctx context.Context, body BurnBatchBody, localVarOptionals *MultiTokensERC1155OrCompatibleApiBurnMultiTokenBatchOpts) (InlineResponse2005, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2005
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/multitoken/burn/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2005
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v InlineResponse40366
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
MultiTokensERC1155OrCompatibleApiService Deploy a Multi Token smart contract
&lt;p&gt;&lt;b&gt;2 credits per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Deploy Multi Token Smart Contract. This method creates new ERC1155 Smart Contract (Multi Tokens) on the blockchain. Smart contract is standardized and audited. It is possible to mint, burn and transfer tokens. It is also possible to mint multiple tokens at once.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;b&gt;Signing a transaction&lt;/b&gt;&lt;/p&gt; &lt;p&gt;When deploying a Multi Token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.&lt;/p&gt; &lt;p&gt;Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the &lt;b&gt;testnet&lt;/b&gt; of a blockchain.&lt;/p&gt; &lt;p&gt;For signing transactions on the &lt;b&gt;mainnet&lt;/b&gt;, we strongly recommend that you use the Tatum &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Key Management System (KMS)&lt;/a&gt; and provide the signature ID instead of the private key in the API. Alternatively, you can use the &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-js\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum JavaScript client&lt;/a&gt;.&lt;/p&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *MultiTokensERC1155OrCompatibleApiDeployMultiTokenOpts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.
@return InlineResponse2005
*/

type MultiTokensERC1155OrCompatibleApiDeployMultiTokenOpts struct {
    XTestnetType optional.String
}

func (a *MultiTokensERC1155OrCompatibleApiService) DeployMultiToken(ctx context.Context, body MultitokenDeployBody, localVarOptionals *MultiTokensERC1155OrCompatibleApiDeployMultiTokenOpts) (InlineResponse2005, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2005
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/multitoken/deploy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2005
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v InlineResponse40311
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
MultiTokensERC1155OrCompatibleApiService Mint a Multi Token
&lt;p&gt;&lt;b&gt;2 credits per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Mint a fixed amount of Multi Token and transfer it to destination account. Create and transfer any Multi Token token from smart contract defined in contractAddress. It is possible to add Metadata to the created token with a more detailed information about instead.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Algorand&lt;/li&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;b&gt;Signing a transaction&lt;/b&gt;&lt;/p&gt; &lt;p&gt;When minting a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.&lt;/p&gt; &lt;p&gt;Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the &lt;b&gt;testnet&lt;/b&gt; of a blockchain.&lt;/p&gt; &lt;p&gt;For signing transactions on the &lt;b&gt;mainnet&lt;/b&gt;, we strongly recommend that you use the Tatum &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Key Management System (KMS)&lt;/a&gt; and provide the signature ID instead of the private key in the API. Alternatively, you can use the &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-js\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum JavaScript client&lt;/a&gt;.&lt;/p&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *MultiTokensERC1155OrCompatibleApiMintMultiTokenOpts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.
@return InlineResponse2005
*/

type MultiTokensERC1155OrCompatibleApiMintMultiTokenOpts struct {
    XTestnetType optional.String
}

func (a *MultiTokensERC1155OrCompatibleApiService) MintMultiToken(ctx context.Context, body MultitokenMintBody, localVarOptionals *MultiTokensERC1155OrCompatibleApiMintMultiTokenOpts) (InlineResponse2005, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2005
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/multitoken/mint"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2005
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v InlineResponse40366
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
MultiTokensERC1155OrCompatibleApiService Mint multiple Multi Tokens
&lt;p&gt;&lt;b&gt;2 credits per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Create a fixed amount of multiple Multi Tokens Tokens and transfer them to destination account in one transaction. Create and transfer Multi Tokens tokens from smart contract defined in contractAddress.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;b&gt;Signing a transaction&lt;/b&gt;&lt;/p&gt; &lt;p&gt;When minting multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.&lt;/p&gt; &lt;p&gt;Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the &lt;b&gt;testnet&lt;/b&gt; of a blockchain.&lt;/p&gt; &lt;p&gt;For signing transactions on the &lt;b&gt;mainnet&lt;/b&gt;, we strongly recommend that you use the Tatum &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Key Management System (KMS)&lt;/a&gt; and provide the signature ID instead of the private key in the API. Alternatively, you can use the &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-js\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum JavaScript client&lt;/a&gt;.&lt;/p&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *MultiTokensERC1155OrCompatibleApiMintMultiTokenBatchOpts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.
@return InlineResponse2005
*/

type MultiTokensERC1155OrCompatibleApiMintMultiTokenBatchOpts struct {
    XTestnetType optional.String
}

func (a *MultiTokensERC1155OrCompatibleApiService) MintMultiTokenBatch(ctx context.Context, body MintBatchBody1, localVarOptionals *MultiTokensERC1155OrCompatibleApiMintMultiTokenBatchOpts) (InlineResponse2005, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2005
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/multitoken/mint/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2005
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v InlineResponse40366
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
MultiTokensERC1155OrCompatibleApiService Get all Multi Tokens that a blockchain address holds
&lt;p&gt;&lt;b&gt;1 credit per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Get all Multi Tokens that a blockchain address holds. The Multi Tokens are returned grouped by the smart contracts they were minted on.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;/ul&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param chain Blockchain to work with
 * @param address Blockchain address
 * @param optional nil or *MultiTokensERC1155OrCompatibleApiMultiTokenGetAddressBalanceOpts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.
@return []InlineResponse20048
*/

type MultiTokensERC1155OrCompatibleApiMultiTokenGetAddressBalanceOpts struct {
    XTestnetType optional.String
}

func (a *MultiTokensERC1155OrCompatibleApiService) MultiTokenGetAddressBalance(ctx context.Context, chain string, address string, localVarOptionals *MultiTokensERC1155OrCompatibleApiMultiTokenGetAddressBalanceOpts) ([]InlineResponse20048, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InlineResponse20048
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/multitoken/address/balance/{chain}/{address}"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", fmt.Sprintf("%v", chain), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"address"+"}", fmt.Sprintf("%v", address), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InlineResponse20048
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v Error403Celo
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
MultiTokensERC1155OrCompatibleApiService Get the amount of a specific MultiToken that a blockchain address holds
&lt;p&gt;&lt;b&gt;1 credit per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Get the amount of a specific Multi Token (minted on the smart contract specified by the &lt;code&gt;contractAddress&lt;/code&gt; path parameter in the request endpoint URL) that a blockchain address holds.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;/ul&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param chain Blockchain to work with
 * @param address The blockchain address that you want to get the token balance of
 * @param contractAddress The address of the Multi Token smart contract
 * @param tokenId The ID of the Multi Token
 * @param optional nil or *MultiTokensERC1155OrCompatibleApiMultiTokenGetBalanceOpts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.
@return []string
*/

type MultiTokensERC1155OrCompatibleApiMultiTokenGetBalanceOpts struct {
    XTestnetType optional.String
}

func (a *MultiTokensERC1155OrCompatibleApiService) MultiTokenGetBalance(ctx context.Context, chain string, address string, contractAddress string, tokenId string, localVarOptionals *MultiTokensERC1155OrCompatibleApiMultiTokenGetBalanceOpts) ([]string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/multitoken/balance/{chain}/{contractAddress}/{address}/{tokenId}"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", fmt.Sprintf("%v", chain), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"address"+"}", fmt.Sprintf("%v", address), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contractAddress"+"}", fmt.Sprintf("%v", contractAddress), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tokenId"+"}", fmt.Sprintf("%v", tokenId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v Error403Celo
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
MultiTokensERC1155OrCompatibleApiService Get the amount of one or multiple Multi Tokens for multiple blockchain addresses
&lt;p&gt;&lt;b&gt;1 credit per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;For multiple blockchain addresses, get the amount of one or multiple Multi Tokens (minted on the smart contract specified by the &lt;code&gt;contractAddress&lt;/code&gt; path parameter in the request endpoint URL) that those addresses hold.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;/ul&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param chain Blockchain to work with
 * @param contractAddress The address of the Multi Token smart contract
 * @param tokenId Comma-separated IDs of the Multi Tokens to get the amounts for
 * @param address Comma-separated blockchain addresses to get the token balance for
 * @param optional nil or *MultiTokensERC1155OrCompatibleApiMultiTokenGetBalanceBatchOpts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.
@return []string
*/

type MultiTokensERC1155OrCompatibleApiMultiTokenGetBalanceBatchOpts struct {
    XTestnetType optional.String
}

func (a *MultiTokensERC1155OrCompatibleApiService) MultiTokenGetBalanceBatch(ctx context.Context, chain string, contractAddress string, tokenId string, address string, localVarOptionals *MultiTokensERC1155OrCompatibleApiMultiTokenGetBalanceBatchOpts) ([]string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/multitoken/balance/batch/{chain}/{contractAddress}"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", fmt.Sprintf("%v", chain), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contractAddress"+"}", fmt.Sprintf("%v", contractAddress), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("tokenId", parameterToString(tokenId, ""))
	localVarQueryParams.Add("address", parameterToString(address, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v Error403Celo
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
MultiTokensERC1155OrCompatibleApiService Get Multi Token metadata
&lt;p&gt;&lt;b&gt;1 credit per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Get Multi Token metadata.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;/ul&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param chain Blockchain to work with
 * @param token Token ID
 * @param contractAddress Multi Token contract address
 * @param optional nil or *MultiTokensERC1155OrCompatibleApiMultiTokenGetMetadataOpts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.
@return InlineResponse20043
*/

type MultiTokensERC1155OrCompatibleApiMultiTokenGetMetadataOpts struct {
    XTestnetType optional.String
}

func (a *MultiTokensERC1155OrCompatibleApiService) MultiTokenGetMetadata(ctx context.Context, chain string, token string, contractAddress string, localVarOptionals *MultiTokensERC1155OrCompatibleApiMultiTokenGetMetadataOpts) (InlineResponse20043, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse20043
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/multitoken/metadata/{chain}/{contractAddress}/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", fmt.Sprintf("%v", chain), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", fmt.Sprintf("%v", token), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contractAddress"+"}", fmt.Sprintf("%v", contractAddress), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(token) > 32 {
		return localVarReturnValue, nil, reportError("token must have less than 32 elements")
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse20043
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v Error403Celo
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
MultiTokensERC1155OrCompatibleApiService Get a Multi Token transaction by its hash
&lt;p&gt;&lt;b&gt;1 credit per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Get Multi Token transaction by transaction hash.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;/ul&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param chain Blockchain to work with
 * @param hash Transaction hash
 * @param optional nil or *MultiTokensERC1155OrCompatibleApiMultiTokenGetTransactionOpts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.
@return InlineResponse20047
*/

type MultiTokensERC1155OrCompatibleApiMultiTokenGetTransactionOpts struct {
    XTestnetType optional.String
}

func (a *MultiTokensERC1155OrCompatibleApiService) MultiTokenGetTransaction(ctx context.Context, chain string, hash string, localVarOptionals *MultiTokensERC1155OrCompatibleApiMultiTokenGetTransactionOpts) (InlineResponse20047, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse20047
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/multitoken/transaction/{chain}/{hash}"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", fmt.Sprintf("%v", chain), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hash"+"}", fmt.Sprintf("%v", hash), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse20047
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v InlineResponse4039
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
MultiTokensERC1155OrCompatibleApiService Get Multi Token transactions on a blockchain address
&lt;p&gt;&lt;b&gt;1 credit per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Get incoming and outgoing Multi Token transactions on a blockchain address.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;/ul&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param chain Blockchain to work with
 * @param address Account address you want to get balance of
 * @param tokenAddress Address of the token smart contract
 * @param pageSize Max number of items per page is 50.
 * @param optional nil or *MultiTokensERC1155OrCompatibleApiMultiTokenGetTransactionByAddressOpts - Optional Parameters:
     * @param "Offset" (optional.Float64) -  Offset to obtain next page of the data.
     * @param "From" (optional.Float64) -  Transactions from this block onwards will be included.
     * @param "To" (optional.Float64) -  Transactions up to this block will be included.
@return []Object
*/

type MultiTokensERC1155OrCompatibleApiMultiTokenGetTransactionByAddressOpts struct {
    Offset optional.Float64
    From optional.Float64
    To optional.Float64
}

func (a *MultiTokensERC1155OrCompatibleApiService) MultiTokenGetTransactionByAddress(ctx context.Context, chain string, address string, tokenAddress string, pageSize float64, localVarOptionals *MultiTokensERC1155OrCompatibleApiMultiTokenGetTransactionByAddressOpts) ([]Object, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Object
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/multitoken/transaction/{chain}/{address}/{tokenAddress}"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", fmt.Sprintf("%v", chain), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"address"+"}", fmt.Sprintf("%v", address), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tokenAddress"+"}", fmt.Sprintf("%v", tokenAddress), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if pageSize < 1 {
		return localVarReturnValue, nil, reportError("pageSize must be greater than 1")
	}
	if pageSize > 50 {
		return localVarReturnValue, nil, reportError("pageSize must be less than 50")
	}

	localVarQueryParams.Add("pageSize", parameterToString(pageSize, ""))
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.From.IsSet() {
		localVarQueryParams.Add("from", parameterToString(localVarOptionals.From.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.To.IsSet() {
		localVarQueryParams.Add("to", parameterToString(localVarOptionals.To.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Object
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
MultiTokensERC1155OrCompatibleApiService Transfer a Multi Token
&lt;p&gt;&lt;b&gt;2 credits per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Transfer a certain amount of Multi Token from account to another account. Transfer Multi Tokens token from smart contract defined in contractAddress.&lt;/p&gt; &lt;p&gt;Only 1 specific token with specified tokenId and value can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and blockchains.&lt;/p&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Algorand&lt;/li&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;b&gt;Signing a transaction&lt;/b&gt;&lt;/p&gt; &lt;p&gt;When transferring a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.&lt;/p&gt; &lt;p&gt;Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the &lt;b&gt;testnet&lt;/b&gt; of a blockchain.&lt;/p&gt; &lt;p&gt;For signing transactions on the &lt;b&gt;mainnet&lt;/b&gt;, we strongly recommend that you use the Tatum &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Key Management System (KMS)&lt;/a&gt; and provide the signature ID instead of the private key in the API. Alternatively, you can use the &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-js\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum JavaScript client&lt;/a&gt;.&lt;/p&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *MultiTokensERC1155OrCompatibleApiTransferMultiTokenOpts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.
@return InlineResponse2005
*/

type MultiTokensERC1155OrCompatibleApiTransferMultiTokenOpts struct {
    XTestnetType optional.String
}

func (a *MultiTokensERC1155OrCompatibleApiService) TransferMultiToken(ctx context.Context, body MultitokenTransactionBody, localVarOptionals *MultiTokensERC1155OrCompatibleApiTransferMultiTokenOpts) (InlineResponse2005, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2005
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/multitoken/transaction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2005
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v InlineResponse40366
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
MultiTokensERC1155OrCompatibleApiService Transfer multiple Multi Tokens
&lt;p&gt;&lt;b&gt;2 credits per API call&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Transfer Multi Token Batch from account to various other accounts in one transaction. Transfer multiple Multi Tokens token from smart contract defined in contractAddress.&lt;/p&gt; &lt;p&gt;Multiple token with specified tokenIds and values can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and BSC.&lt;/b&gt; &lt;p&gt;This API is supported for the following blockchains:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;BNB Smart Chain&lt;/li&gt; &lt;li&gt;Celo&lt;/li&gt; &lt;li&gt;Ethereum&lt;/li&gt; &lt;li&gt;Harmony&lt;/li&gt; &lt;li&gt;Klaytn&lt;/li&gt; &lt;li&gt;KuCoin Community Chain&lt;/li&gt; &lt;li&gt;Polygon&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;b&gt;Signing a transaction&lt;/b&gt;&lt;/p&gt; &lt;p&gt;When transferring multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.&lt;/p&gt; &lt;p&gt;Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the &lt;b&gt;testnet&lt;/b&gt; of a blockchain.&lt;/p&gt; &lt;p&gt;For signing transactions on the &lt;b&gt;mainnet&lt;/b&gt;, we strongly recommend that you use the Tatum &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-kms\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Key Management System (KMS)&lt;/a&gt; and provide the signature ID instead of the private key in the API. Alternatively, you can use the &lt;a href&#x3D;\&quot;https://github.com/tatumio/tatum-js\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Tatum JavaScript client&lt;/a&gt;.&lt;/p&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *MultiTokensERC1155OrCompatibleApiTransferMultiTokenBatchOpts - Optional Parameters:
     * @param "XTestnetType" (optional.String) -  Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.
@return InlineResponse2005
*/

type MultiTokensERC1155OrCompatibleApiTransferMultiTokenBatchOpts struct {
    XTestnetType optional.String
}

func (a *MultiTokensERC1155OrCompatibleApiService) TransferMultiTokenBatch(ctx context.Context, body TransactionBatchBody, localVarOptionals *MultiTokensERC1155OrCompatibleApiTransferMultiTokenBatchOpts) (InlineResponse2005, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2005
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/multitoken/transaction/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTestnetType.IsSet() {
		localVarHeaderParams["x-testnet-type"] = parameterToString(localVarOptionals.XTestnetType.Value(), "")
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2005
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v Error400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v InlineResponse40366
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v Error500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
